{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Notice","text":"<p>Documentation for this tool has been moved to the centralized PORI documentation</p>"},{"location":"reference/ipr/annotate/","title":"ipr/annotate","text":"<p>handles annotating variants with annotation information from graphkb</p>"},{"location":"reference/ipr/annotate/#reported_copy_variants","title":"REPORTED_COPY_VARIANTS","text":"<pre><code>REPORTED_COPY_VARIANTS = (INPUT_COPY_CATEGORIES.AMP, INPUT_COPY_CATEGORIES.DEEP)\n</code></pre>"},{"location":"reference/ipr/annotate/#get_gene_information","title":"get_gene_information()","text":"<p>Create the Gene Info object for upload to IPR with the other report information.</p> <pre><code>def get_gene_information(\n    graphkb_conn: GraphKBConnection, gene_names: Sequence[str]\n) -&gt; List[IprGene]:\n</code></pre> <p>Args</p> <ul> <li>graphkb_conn (<code>GraphKBConnection</code>): [description]</li> <li>gene_names (<code>Sequence[str]</code>): [description]</li> </ul> <p>Returns</p> <ul> <li>List[IprGene]</li> </ul>"},{"location":"reference/ipr/annotate/#get_statements_from_variants","title":"get_statements_from_variants()","text":"<p>Given a list of variant records from GraphKB, return all the related statements.</p> <pre><code>def get_statements_from_variants(\n    graphkb_conn: GraphKBConnection, variants: List[Variant]\n) -&gt; List[GkbStatement]:\n</code></pre> <p>Args</p> <ul> <li>graphkb_conn (<code>GraphKBConnection</code>): the graphkb api connection object</li> <li>variants (<code>List[Variant]</code>): list of variant records</li> </ul> <p>Returns</p> <ul> <li>List[GkbStatement]: list of Statement records from graphkb</li> </ul>"},{"location":"reference/ipr/annotate/#get_second_pass_variants","title":"get_second_pass_variants()","text":"<p>Given a list of statements that have been matched, convert these to new category variants to be used in a second-pass matching.</p> <pre><code>def get_second_pass_variants(\n    graphkb_conn: GraphKBConnection, statements: List[GkbStatement]\n) -&gt; List[Variant]:\n</code></pre> <p>Args</p> <ul> <li>graphkb_conn (<code>GraphKBConnection</code>)</li> <li>statements (List[GkbStatement])</li> </ul> <p>Returns</p> <ul> <li><code>List[Variant]</code></li> </ul>"},{"location":"reference/ipr/annotate/#get_ipr_statements_from_variants","title":"get_ipr_statements_from_variants()","text":"<p>IPR upload formatted GraphKB statements from the list of variants.</p> <p>Matches to GraphKB statements from the list of input variants. From these results matches again with the inferred variants. Then returns the results formatted for upload to IPR</p> <pre><code>def get_ipr_statements_from_variants(\n    graphkb_conn: GraphKBConnection, matches: List[Variant], disease_name: str\n) -&gt; List[KbMatch]:\n</code></pre> <p>Args</p> <ul> <li>graphkb_conn (<code>GraphKBConnection</code>)</li> <li>matches (<code>List[Variant]</code>)</li> <li>disease_name (<code>str</code>)</li> </ul> <p>Returns</p> <ul> <li>List[KbMatch]</li> </ul>"},{"location":"reference/ipr/annotate/#annotate_expression_variants","title":"annotate_expression_variants()","text":"<p>Annotate expression variants with GraphKB in the IPR alterations format.</p> <pre><code>def annotate_expression_variants(\n    graphkb_conn: GraphKBConnection,\n    variants: List[IprExprVariant],\n    disease_name: str,\n    show_progress: bool = False,\n) -&gt; List[KbMatch]:\n</code></pre> <p>Args</p> <ul> <li>graphkb_conn (<code>GraphKBConnection</code>): the graphkb api connection object</li> <li>variants (List[IprExprVariant]): list of variants</li> <li>disease_name (<code>str</code>)</li> <li>show_progress (<code>bool</code>)</li> </ul> <p>Returns</p> <ul> <li>List[KbMatch]: list of kbMatches records for IPR</li> </ul>"},{"location":"reference/ipr/annotate/#annotate_copy_variants","title":"annotate_copy_variants()","text":"<p>Annotate allowed copy variants with GraphKB in the IPR alterations format.</p> <pre><code>def annotate_copy_variants(\n    graphkb_conn: GraphKBConnection,\n    variants: List[IprCopyVariant],\n    disease_name: str,\n    show_progress: bool = False,\n) -&gt; List[KbMatch]:\n</code></pre> <p>Args</p> <ul> <li>graphkb_conn (<code>GraphKBConnection</code>): the graphkb api connection object</li> <li>variants (List[IprCopyVariant]): list of variants</li> <li>disease_name (<code>str</code>)</li> <li>show_progress (<code>bool</code>)</li> </ul> <p>Returns</p> <ul> <li>List[KbMatch]: list of kbMatches records for IPR</li> </ul>"},{"location":"reference/ipr/annotate/#annotate_positional_variants","title":"annotate_positional_variants()","text":"<p>Annotate SNP, INDEL or fusion variant calls with GraphKB and return in IPR match format.</p> <pre><code>def annotate_positional_variants(\n    graphkb_conn: GraphKBConnection,\n    variants: Sequence[IprStructuralVariant],\n    disease_name: str,\n    show_progress: bool = False,\n) -&gt; List[KbMatch]:\n</code></pre> <p>Args</p> <ul> <li>graphkb_conn (<code>GraphKBConnection</code>): the graphkb api connection object</li> <li>variants (Sequence[IprStructuralVariant]): list of variants. Defaults to [].</li> <li>disease_name (<code>str</code>): GraphKB disease name for statement matching.  'cancer' is most general</li> <li>show_progress (<code>bool</code>): Progressbar displayed for long runs.</li> </ul> <p>Returns</p> <ul> <li>List[KbMatch]: list of kbMatches records for IPR</li> </ul>"},{"location":"reference/ipr/connection/","title":"ipr/connection","text":""},{"location":"reference/ipr/connection/#image_max","title":"IMAGE_MAX","text":"<pre><code>IMAGE_MAX = 20  # cannot upload more than 20 images at a time\n</code></pre>"},{"location":"reference/ipr/connection/#class-iprconnection","title":"class IprConnection","text":""},{"location":"reference/ipr/connection/#iprconnectionrequest","title":"IprConnection.request()","text":"<p>Request wrapper to handle adding common headers and logging</p> <pre><code>def request(self, endpoint: str, method: str = 'GET', **kwargs) -&gt; Dict:\n</code></pre> <p>Args</p> <ul> <li>endpoint (<code>str</code>): api endpoint, excluding the base uri</li> <li>method (<code>str</code>): the http method. Defaults to 'GET'.</li> </ul> <p>Returns</p> <ul> <li><code>Dict</code>: the json response as a python dict</li> </ul>"},{"location":"reference/ipr/connection/#iprconnectionpost","title":"IprConnection.post()","text":"<p>Convenience method for making post requests</p> <pre><code>def post(self, uri: str, data: Dict = {}, **kwargs) -&gt; Dict:\n</code></pre> <p>Args</p> <ul> <li>uri (<code>str</code>)</li> <li>data (<code>Dict</code>)</li> </ul> <p>Returns</p> <ul> <li><code>Dict</code></li> </ul>"},{"location":"reference/ipr/connection/#iprconnectionset_analyst_comments","title":"IprConnection.set_analyst_comments()","text":"<p>Update report comments to an existing report</p> <pre><code>def set_analyst_comments(self, report_id: str, data: Dict) -&gt; Dict:\n</code></pre> <p>Args</p> <ul> <li>report_id (<code>str</code>)</li> <li>data (<code>Dict</code>)</li> </ul> <p>Returns</p> <ul> <li><code>Dict</code></li> </ul> <p>!!! todo     Add to main upload.     Pending: https://www.bcgsc.ca/jira/browse/DEVSU-1177</p>"},{"location":"reference/ipr/connection/#iprconnectionpost_images","title":"IprConnection.post_images()","text":"<p>Post images to the report</p> <pre><code>def post_images(self, report_id: str, files: Dict[str, str], data: Dict[str, str] = {}) -&gt; None:\n</code></pre> <p>Args</p> <ul> <li>report_id (<code>str</code>)</li> <li>files (<code>Dict[str, str]</code>)</li> <li>data (<code>Dict[str, str]</code>)</li> </ul>"},{"location":"reference/ipr/inputs/","title":"ipr/inputs","text":"<p>Read/Validate the variant input files</p>"},{"location":"reference/ipr/inputs/#specification","title":"SPECIFICATION","text":"<pre><code>SPECIFICATION = os.path.join(os.path.dirname(__file__), 'content.spec.json')\n</code></pre>"},{"location":"reference/ipr/inputs/#copy_req","title":"COPY_REQ","text":"<pre><code>COPY_REQ = ['gene', 'kbCategory']\n</code></pre>"},{"location":"reference/ipr/inputs/#copy_key","title":"COPY_KEY","text":"<pre><code>COPY_KEY = ['gene']\n</code></pre>"},{"location":"reference/ipr/inputs/#copy_optional","title":"COPY_OPTIONAL","text":"<pre><code>COPY_OPTIONAL = [\n    'cnvState',\n    'copyChange',\n    'lohState',  # Loss of Heterzygosity state - informative detail to analyst\n    'chromosomeBand',\n    'start',\n    'end',\n    'size',\n    'log2Cna',\n    'cna',\n]\n</code></pre>"},{"location":"reference/ipr/inputs/#small_mut_req","title":"SMALL_MUT_REQ","text":"<pre><code>SMALL_MUT_REQ = ['gene', 'proteinChange']\n</code></pre>"},{"location":"reference/ipr/inputs/#small_mut_key","title":"SMALL_MUT_KEY","text":"<pre><code>SMALL_MUT_KEY = SMALL_MUT_REQ + [\n    'altSeq',\n    'chromosome',\n    'endPosition',\n    'refSeq',\n    'startPosition',\n    'transcript',\n</code></pre>"},{"location":"reference/ipr/inputs/#small_mut_optional","title":"SMALL_MUT_OPTIONAL","text":"<pre><code>SMALL_MUT_OPTIONAL = [\n    'altSeq',\n    'chromosome',\n    'endPosition',\n    'germline',\n    'hgvsCds',\n    'hgvsGenomic',\n    'hgvsProtein',\n    'ncbiBuild',\n    'normalAltCount',\n    'normalDepth',\n    'normalRefCount',\n    'refSeq',\n    'rnaAltCount',\n    'rnaDepth',\n    'rnaRefCount',\n    'startPosition',\n    'transcript',\n    'tumourAltCount',\n    'tumourAltCopies',\n    'tumourDepth',\n    'tumourRefCount',\n    'tumourRefCopies',\n    'zygosity',\n]\n</code></pre>"},{"location":"reference/ipr/inputs/#exp_req","title":"EXP_REQ","text":"<pre><code>EXP_REQ = ['gene', 'kbCategory']\n</code></pre>"},{"location":"reference/ipr/inputs/#exp_key","title":"EXP_KEY","text":"<pre><code>EXP_KEY = ['gene']\n</code></pre>"},{"location":"reference/ipr/inputs/#exp_optional","title":"EXP_OPTIONAL","text":"<pre><code>EXP_OPTIONAL = [\n    'biopsySiteFoldChange',\n    'biopsySitePercentile',\n    'biopsySiteQC',\n    'biopsySiteZScore',\n    'biopsySitekIQR',\n    'diseaseFoldChange',\n    'diseasekIQR',\n    'diseasePercentile',\n    'diseaseQC',\n    'diseaseZScore',\n    'expressionState',\n    'histogramImage',\n    'primarySiteFoldChange',\n    'primarySitekIQR',\n    'primarySitePercentile',\n    'primarySiteQC',\n    'primarySiteZScore',\n    'internalPancancerFoldChange',\n    'internalPancancerkIQR',\n    'internalPancancerPercentile',\n    'internalPancancerQC',\n    'internalPancancerZScore',\n    'rnaReads',\n    'rpkm',\n    'tpm',\n]\n</code></pre>"},{"location":"reference/ipr/inputs/#sv_req","title":"SV_REQ","text":"<pre><code>SV_REQ = [\n    'eventType',\n    'breakpoint',\n    'gene1',  # prev: nterm_hugo\n    'gene2',  # prev: cterm_hugo\n    'exon1',  # n-terminal\n    'exon2',  # c-terminal\n]\n</code></pre>"},{"location":"reference/ipr/inputs/#sv_key","title":"SV_KEY","text":"<pre><code>SV_KEY = SV_REQ[:]\n</code></pre>"},{"location":"reference/ipr/inputs/#sv_optional","title":"SV_OPTIONAL","text":"<pre><code>SV_OPTIONAL = [\n    'ctermTranscript',\n    'ntermTranscript',\n    'ctermGene',  # combined hugo ensembl form\n    'ntermGene',  # combined hugo ensembl form\n    'detectedIn',\n    'conventionalName',\n    'svg',\n    'svgTitle',\n    'name',\n    'frame',\n    'omicSupport',\n    'highQuality',\n]\n</code></pre>"},{"location":"reference/ipr/inputs/#defaultvalidatingdraft7validator","title":"DefaultValidatingDraft7Validator","text":"<pre><code>DefaultValidatingDraft7Validator = extend_with_default(jsonschema.Draft7Validator)\n</code></pre>"},{"location":"reference/ipr/inputs/#validate_variant_rows","title":"validate_variant_rows()","text":"<ul> <li>check that the required columns are present</li> <li>check that a unique key can be formed for each row</li> <li>drop any non-defined columns</li> </ul> <pre><code>def validate_variant_rows(\n    rows: Iterable[Dict], required: List[str], optional: List[str], row_to_key: Callable\n) -&gt; List[IprVariant]:\n</code></pre> <p>Args</p> <ul> <li>rows (<code>Iterable[Dict]</code>): the input files rows</li> <li>required (<code>List[str]</code>)</li> <li>optional (<code>List[str]</code>): list of optional column names</li> <li>row_to_key (<code>Callable</code>): function to generate a key for a given row</li> </ul> <p>Returns</p> <ul> <li>List[IprVariant]: the rows from the tab file as dictionaries</li> </ul> <p>Raises</p> <ul> <li><code>ValueError</code>: row keys are not unique</li> <li><code>ValueError</code>: A required column is missing</li> </ul>"},{"location":"reference/ipr/inputs/#preprocess_copy_variants","title":"preprocess_copy_variants()","text":"<p>Validate the input rows contain the minimum required fields and generate any default values where possible</p> <pre><code>def preprocess_copy_variants(rows: Iterable[Dict]) -&gt; List[IprCopyVariant]:\n</code></pre> <p>Args</p> <ul> <li>rows (<code>Iterable[Dict]</code>)</li> </ul> <p>Returns</p> <ul> <li>List[IprCopyVariant]</li> </ul>"},{"location":"reference/ipr/inputs/#preprocess_small_mutations","title":"preprocess_small_mutations()","text":"<p>Validate the input rows contain the minimum required fields and generate any default values where possible</p> <pre><code>def preprocess_small_mutations(rows: Iterable[Dict]) -&gt; List[IprSmallMutationVariant]:\n</code></pre> <p>Args</p> <ul> <li>rows (<code>Iterable[Dict]</code>)</li> </ul> <p>Returns</p> <ul> <li>List[IprSmallMutationVariant]</li> </ul>"},{"location":"reference/ipr/inputs/#preprocess_expression_variants","title":"preprocess_expression_variants()","text":"<p>Validate the input rows contain the minimum required fields and generate any default values where possible</p> <pre><code>def preprocess_expression_variants(rows: Iterable[Dict]) -&gt; List[IprExprVariant]:\n</code></pre> <p>Args</p> <ul> <li>rows (<code>Iterable[Dict]</code>)</li> </ul> <p>Returns</p> <ul> <li>List[IprExprVariant]</li> </ul>"},{"location":"reference/ipr/inputs/#create_graphkb_sv_notation","title":"create_graphkb_sv_notation()","text":"<p>Generate GKB/IPR fusion style notation from a structural variant.</p> <pre><code>def create_graphkb_sv_notation(row: IprFusionVariant) -&gt; str:\n</code></pre> <p>Args</p> <ul> <li>row (IprFusionVariant)</li> </ul> <p>Returns</p> <ul> <li><code>str</code></li> </ul>"},{"location":"reference/ipr/inputs/#preprocess_structural_variants","title":"preprocess_structural_variants()","text":"<p>Validate the input rows contain the minimum required fields and generate any default values where possible</p> <pre><code>def preprocess_structural_variants(rows: Iterable[Dict]) -&gt; List[IprFusionVariant]:\n</code></pre> <p>Args</p> <ul> <li>rows (<code>Iterable[Dict]</code>)</li> </ul> <p>Returns</p> <ul> <li>List[IprFusionVariant]</li> </ul>"},{"location":"reference/ipr/inputs/#check_variant_links","title":"check_variant_links()","text":"<p>Check matching information for any genes with variants. Warn about genes with only one experimental measure.</p> <pre><code>def check_variant_links(\n    small_mutations: List[IprSmallMutationVariant],\n    expression_variants: List[IprExprVariant],\n    copy_variants: List[IprCopyVariant],\n    structural_variants: List[IprFusionVariant],\n) -&gt; Set[str]:\n</code></pre> <p>Args</p> <ul> <li>small_mutations (List[IprSmallMutationVariant]): list of small mutations</li> <li>expression_variants (List[IprExprVariant]): list of expression variants</li> <li>copy_variants (List[IprCopyVariant]): list of copy variants</li> <li>structural_variants (List[IprFusionVariant]): list of structural variants</li> </ul> <p>Returns</p> <ul> <li><code>Set[str]</code>: set of gene names with variants (used for filtering before upload to IPR)</li> </ul>"},{"location":"reference/ipr/inputs/#check_comparators","title":"check_comparators()","text":"<p>Given the optional content dictionary, check that based on the analyses present the correct/sufficient comparators have also been specified</p> <pre><code>def check_comparators(content: Dict, expresssionVariants: List[IprExprVariant] = []) -&gt; None:\n</code></pre> <p>Args</p> <ul> <li>content (<code>Dict</code>)</li> <li>expresssionVariants (List[IprExprVariant])</li> </ul>"},{"location":"reference/ipr/inputs/#validate_report_content","title":"validate_report_content()","text":"<p>Validate a report content input JSON object against the schema specification</p> <p>Adds defaults as reccommended by: https://python-jsonschema.readthedocs.io/en/latest/faq/#why-doesn-t-my-schema-s-default-property-set-the-default-on-my-instance</p> <pre><code>def validate_report_content(content: Dict, schema_file: str = SPECIFICATION) -&gt; None:\n</code></pre> <p>Args</p> <ul> <li>content (<code>Dict</code>)</li> <li>schema_file (<code>str</code>)</li> </ul>"},{"location":"reference/ipr/ipr/","title":"ipr/ipr","text":"<p>Contains functions specific to formatting reports for IPR that are unlikely to be used by other reporting systems</p>"},{"location":"reference/ipr/ipr/#filter_structural_variants","title":"filter_structural_variants()","text":"<p>Filter structural variants to remove non-high quality events unless they are matched/annotated or they involve a gene that is a known fusion partner</p> <pre><code>def filter_structural_variants(\n    structural_variants: List[IprFusionVariant],\n    kb_matches: List[KbMatch],\n    gene_annotations: List[IprGene],\n) -&gt; List[IprFusionVariant]:\n</code></pre> <p>Args</p> <ul> <li>structural_variants (List[IprFusionVariant])</li> <li>kb_matches (List[KbMatch])</li> <li>gene_annotations (List[IprGene])</li> </ul> <p>Returns</p> <ul> <li>List[IprFusionVariant]</li> </ul>"},{"location":"reference/ipr/ipr/#get_evidencelevel_mapping","title":"get_evidencelevel_mapping()","text":"<p>IPR evidence level equivalents of GraphKB evidence returned as a dictionary.</p> <pre><code>def get_evidencelevel_mapping(graphkb_conn: GraphKBConnection) -&gt; Dict[str, str]:\n</code></pre> <p>Args</p> <ul> <li>graphkb_conn (<code>GraphKBConnection</code>): the graphkb api connection object</li> </ul> <p>Returns</p> <ul> <li><code>Dict[str, str]</code>: dictionary mapping all EvidenceLevel RIDs to corresponding IPR EvidenceLevel displayName</li> </ul>"},{"location":"reference/ipr/ipr/#convert_statements_to_alterations","title":"convert_statements_to_alterations()","text":"<p>Convert statements matched from graphkb into IPR equivalent representations.</p> <pre><code>def convert_statements_to_alterations(\n    graphkb_conn: GraphKBConnection,\n    statements: List[GkbStatement],\n    disease_name: str,\n    variant_matches: Iterable[str],\n) -&gt; List[KbMatch]:\n</code></pre> <p>Args</p> <ul> <li>graphkb_conn (<code>GraphKBConnection</code>): the graphkb connection object</li> <li>statements (List[GkbStatement]): list of statement records from graphkb</li> <li>disease_name (<code>str</code>): name of the cancer type for the patient being reported on</li> <li>variant_matches (<code>Iterable[str]</code>): the list of RIDs the variant matched for these statements</li> </ul> <p>Returns</p> <ul> <li>List[KbMatch]: IPR graphkb row representations Notes: - only report disease matched prognostic markers https://www.bcgsc.ca/jira/browse/GERO-72 and GERO-196</li> </ul> <p>Raises</p> <ul> <li><code>ValueError</code>: could not find the disease type in GraphKB</li> </ul>"},{"location":"reference/ipr/ipr/#select_expression_plots","title":"select_expression_plots()","text":"<p>Given the list of expression variants, determine which expression historgram plots should be included in the IPR upload. This filters them based on the graphkb annotations to avoid loading more images than are required</p> <pre><code>def select_expression_plots(\n    kb_matches: List[KbMatch], all_variants: Sequence[IprVariant]\n) -&gt; List[ImageDefinition]:\n</code></pre> <p>Args</p> <ul> <li>kb_matches (List[KbMatch]): the IPR graphkb annoations for all variants</li> <li>all_variants (Sequence[IprVariant])</li> </ul> <p>Returns</p> <ul> <li>List[ImageDefinition]: list of expression images to be loaded by IPR</li> </ul>"},{"location":"reference/ipr/ipr/#create_key_alterations","title":"create_key_alterations()","text":"<p>Creates the list of genomic key alterations which summarizes all the variants matched by the KB This list of matches is also used to create the variant counts</p> <pre><code>def create_key_alterations(\n    kb_matches: List[KbMatch], all_variants: Sequence[IprVariant]\n) -&gt; Tuple[List[Dict], Dict]:\n</code></pre> <p>Args</p> <ul> <li>kb_matches (List[KbMatch])</li> <li>all_variants (Sequence[IprVariant])</li> </ul> <p>Returns</p> <ul> <li><code>Tuple[List[Dict], Dict]</code></li> </ul>"},{"location":"reference/ipr/ipr/#germline_kb_matches","title":"germline_kb_matches()","text":"<p>Filter kb_matches for matching to germline or somatic events using the 'germline' optional property.</p> <p>Statements related to pharmacogenomic toxicity or cancer predisposition are only relevant if the variant is present in the germline of the patient. Other statements, such as diagnostic or recurrent oncogenic mutations, are only relevant as somatic events in cancer.  Germline variants are excluded from these matches.</p> <p>Params: kb_matches: KbMatch statements to be filtered.  'variant' properties must match 'key' in all_variants. all_variants: IprVariants, with a 'germline' property, that were used for kb_matches creation. assume_somatic: Whether to assume somatic or germline when no 'germline' property exists in the variant.</p> <pre><code>def germline_kb_matches(\n    kb_matches: List[KbMatch], all_variants: Sequence[IprVariant], assume_somatic: bool = True\n) -&gt; List[KbMatch]:\n</code></pre> <p>Args</p> <ul> <li>kb_matches (List[KbMatch])</li> <li>all_variants (Sequence[IprVariant])</li> <li>assume_somatic (<code>bool</code>)</li> </ul> <p>Returns</p> <ul> <li>List[KbMatch]: filtered list of kb_matches</li> </ul>"},{"location":"reference/ipr/main/","title":"ipr/main","text":""},{"location":"reference/ipr/main/#cache_gene_minimum","title":"CACHE_GENE_MINIMUM","text":"<pre><code>CACHE_GENE_MINIMUM = 5000\n</code></pre>"},{"location":"reference/ipr/main/#clean_unsupported_content","title":"clean_unsupported_content()","text":"<p>Remove unsupported content. This content is either added to facilitate creation or to support upcoming and soon to be supported content that we would like to implement but is not yet supported by the upload</p> <pre><code>def clean_unsupported_content(upload_content: Dict) -&gt; Dict:\n</code></pre> <p>Args</p> <ul> <li>upload_content (<code>Dict</code>)</li> </ul> <p>Returns</p> <ul> <li><code>Dict</code></li> </ul>"},{"location":"reference/ipr/main/#create_report","title":"create_report()","text":"<p>Run the matching and create the report JSON for upload to IPR</p> <pre><code>def create_report(\n    username: str,\n    password: str,\n    content: Dict,\n    ipr_url: str = DEFAULT_URL,\n    log_level: str = 'info',\n    output_json_path: str = None,\n    always_write_output_json: bool = False,\n    ipr_upload: bool = True,\n    interactive: bool = False,\n    graphkb_url: str = '',\n    generate_therapeutics: bool = False,\n    generate_comments: bool = True,\n    match_germline: bool = False,\n    custom_kb_match_filter=None,\n) -&gt; Dict:\n</code></pre> <p>Args</p> <ul> <li>username (<code>str</code>): the username for connecting to GraphKB and IPR</li> <li>password (<code>str</code>): the password for connecting to GraphKB and IPR</li> <li>content (<code>Dict</code>): report content</li> <li>ipr_url (<code>str</code>): base URL to use in connecting to IPR</li> <li>log_level (<code>str</code>): the logging level</li> <li>output_json_path (<code>str</code>): path to a JSON file to output the report upload body.</li> <li>always_write_output_json (<code>bool</code>): with successful IPR upload</li> <li>ipr_upload (<code>bool</code>): upload report to ipr</li> <li>interactive (<code>bool</code>): progressbars for interactive users</li> <li>graphkb_url (<code>str</code>)</li> <li>generate_therapeutics (<code>bool</code>): create therapeutic options for upload with the report</li> <li>generate_comments (<code>bool</code>): create the analyst comments section for upload with the report</li> <li>match_germline (<code>bool</code>): match only germline statements to germline events and non-germline statements to non-germline events.</li> <li>custom_kb_match_filter: function(List[kbMatch]) -&gt; List[kbMatch]</li> </ul> <p>Returns</p> <ul> <li><code>Dict</code>: ipr_conn.upload_report return dictionary</li> </ul>"},{"location":"reference/ipr/summary/","title":"ipr/summary","text":""},{"location":"reference/ipr/summary/#other_diseases","title":"OTHER_DISEASES","text":"<pre><code>OTHER_DISEASES = 'other disease types'\n</code></pre>"},{"location":"reference/ipr/summary/#entrez_gene_url","title":"ENTREZ_GENE_URL","text":"<pre><code>ENTREZ_GENE_URL = 'https://www.ncbi.nlm.nih.gov/gene'\n</code></pre>"},{"location":"reference/ipr/summary/#graphkb_gui","title":"GRAPHKB_GUI","text":"<pre><code>GRAPHKB_GUI = 'https://graphkb.bcgsc.ca'\n</code></pre>"},{"location":"reference/ipr/summary/#filter_by_record_class","title":"filter_by_record_class()","text":"<p>Given a list of records, return the subset matching a class or list of classes.</p> <pre><code>def filter_by_record_class(\n    record_list: Sequence[Record], *record_classes, exclude: bool = False\n) -&gt; List[Record]:\n</code></pre> <p>Args</p> <ul> <li>record_list (<code>Sequence[Record]</code>)</li> </ul> <p>Returns</p> <ul> <li><code>List[Record]</code></li> </ul>"},{"location":"reference/ipr/summary/#create_graphkb_link","title":"create_graphkb_link()","text":"<p>Create a link for a set of statements to the GraphKB client</p> <pre><code>def create_graphkb_link(record_ids: List[str], record_class: str = 'Statement') -&gt; str:\n</code></pre> <p>Args</p> <ul> <li>record_ids (<code>List[str]</code>)</li> <li>record_class (<code>str</code>)</li> </ul> <p>Returns</p> <ul> <li><code>str</code></li> </ul>"},{"location":"reference/ipr/summary/#substitute_sentence_template","title":"substitute_sentence_template()","text":"<p>Create the filled-in sentence template for a given template and list of substitutions which may be the result of the aggregation of 1 or more statements.</p> <pre><code>def substitute_sentence_template(\n    template: str,\n    conditions: List[Ontology],\n    subjects: List[Ontology],\n    relevance: Ontology,\n    evidence: List[Ontology],\n    statement_rids: List[str] = [],\n    disease_matches: Set[str] = set(),\n) -&gt; str:\n</code></pre> <p>Args</p> <ul> <li>template (<code>str</code>)</li> <li>conditions (<code>List[Ontology]</code>)</li> <li>subjects (<code>List[Ontology]</code>)</li> <li>relevance (<code>Ontology</code>)</li> <li>evidence (<code>List[Ontology]</code>)</li> <li>statement_rids (<code>List[str]</code>)</li> <li>disease_matches (<code>Set[str]</code>)</li> </ul> <p>Returns</p> <ul> <li><code>str</code></li> </ul>"},{"location":"reference/ipr/summary/#aggregate_statements","title":"aggregate_statements()","text":"<p>Group Statements that only differ in disease conditions and evidence</p> <pre><code>def aggregate_statements(\n    graphkb_conn: GraphKBConnection,\n    template: str,\n    statements: List[GkbStatement],\n    disease_matches: Set[str],\n) -&gt; Dict[str, str]:\n</code></pre> <p>Args</p> <ul> <li>graphkb_conn (<code>GraphKBConnection</code>)</li> <li>template (<code>str</code>)</li> <li>statements (List[GkbStatement])</li> <li>disease_matches (<code>Set[str]</code>)</li> </ul> <p>Returns</p> <ul> <li><code>Dict[str, str]</code></li> </ul>"},{"location":"reference/ipr/summary/#display_variant","title":"display_variant()","text":"<p>Short, human readable variant description string.</p> <pre><code>def display_variant(variant: IprVariant) -&gt; str:\n</code></pre> <p>Args</p> <ul> <li>variant (IprVariant)</li> </ul> <p>Returns</p> <ul> <li><code>str</code></li> </ul>"},{"location":"reference/ipr/summary/#create_section_html","title":"create_section_html()","text":"<p>Generate HTML for a gene section of the comments</p> <pre><code>def create_section_html(\n    graphkb_conn: GraphKBConnection,\n    gene_name: str,\n    sentences_by_statement_id: Dict[str, str],\n    statements: Dict[str, GkbStatement],\n    exp_variants: List[IprVariant],\n) -&gt; str:\n</code></pre> <p>Args</p> <ul> <li>graphkb_conn (<code>GraphKBConnection</code>)</li> <li>gene_name (<code>str</code>)</li> <li>sentences_by_statement_id (<code>Dict[str, str]</code>)</li> <li>statements (Dict[<code>str</code>, GkbStatement])</li> <li>exp_variants (List[IprVariant])</li> </ul> <p>Returns</p> <ul> <li><code>str</code></li> </ul>"},{"location":"reference/ipr/summary/#section_statements_by_genes","title":"section_statements_by_genes()","text":"<p>Create Dict of statement @rid sets indexed by preferred gene names in conditions.</p> <pre><code>def section_statements_by_genes(\n    graphkb_conn: GraphKBConnection, statements: Sequence[GkbStatement]\n) -&gt; Dict[str, Set[str]]:\n</code></pre> <p>Args</p> <ul> <li>graphkb_conn (<code>GraphKBConnection</code>)</li> <li>statements (Sequence[GkbStatement])</li> </ul> <p>Returns</p> <ul> <li><code>Dict[str, Set[str]]</code></li> </ul>"},{"location":"reference/ipr/summary/#summarize","title":"summarize()","text":"<p>Given a list of GraphKB matches, generate a text summary to add to the report.</p> <pre><code>def summarize(\n    graphkb_conn: GraphKBConnection,\n    matches: Sequence[KbMatch],\n    disease_name: str,\n    variants: Sequence[IprVariant],\n) -&gt; str:\n</code></pre> <p>Args</p> <ul> <li>graphkb_conn (<code>GraphKBConnection</code>)</li> <li>matches (Sequence[KbMatch])</li> <li>disease_name (<code>str</code>)</li> <li>variants (Sequence[IprVariant])</li> </ul> <p>Returns</p> <ul> <li><code>str</code></li> </ul>"},{"location":"reference/ipr/therapeutic_options/","title":"ipr/therapeutic_options","text":"<p>upload variant and report information to IPR</p>"},{"location":"reference/ipr/therapeutic_options/#create_therapeutic_options","title":"create_therapeutic_options()","text":"<p>Generate therapeutic options summary from the list of kb-matches</p> <pre><code>def create_therapeutic_options(\n    graphkb_conn: GraphKBConnection, kb_matches: List[KbMatch], variants: Sequence[IprVariant]\n) -&gt; List[Dict]:\n</code></pre> <p>Args</p> <ul> <li>graphkb_conn (<code>GraphKBConnection</code>)</li> <li>kb_matches (List[KbMatch])</li> <li>variants (Sequence[IprVariant])</li> </ul> <p>Returns</p> <ul> <li><code>List[Dict]</code></li> </ul>"},{"location":"reference/ipr/types/","title":"ipr/types","text":""},{"location":"reference/ipr/types/#iprstructuralvariant","title":"IprStructuralVariant","text":"<pre><code>IprStructuralVariant = Union[IprSmallMutationVariant, IprFusionVariant]\n</code></pre>"},{"location":"reference/ipr/types/#iprvariant","title":"IprVariant","text":"<pre><code>IprVariant = Union[IprCopyVariant, IprExprVariant, IprStructuralVariant]\n</code></pre>"},{"location":"reference/ipr/types/#class-kbmatch","title":"class KbMatch","text":"<p>inherits <code>TypedDict</code></p> <p>Attributes</p> <ul> <li>variant (<code>str</code>)</li> <li>variantType (<code>str</code>)</li> <li>approvedTherapy (<code>bool</code>)</li> <li>category (<code>str</code>)</li> <li>context (<code>str</code>)</li> <li>kbContextId (<code>str</code>)</li> <li>disease (<code>str</code>)</li> <li>evidenceLevel (<code>str</code>)</li> <li>iprEvidenceLevel (<code>Optional[str]</code>)</li> <li>kbStatementId (<code>str</code>)</li> <li>kbVariant (<code>str</code>)</li> <li>kbVariantId (<code>str</code>)</li> <li>matchedCancer (<code>bool</code>)</li> <li>reference (<code>str</code>)</li> <li>relevance (<code>str</code>)</li> <li>kbRelevanceId (<code>str</code>)</li> <li>externalSource (<code>str</code>)</li> <li>externalStatementId (<code>str</code>)</li> <li>reviewStatus (<code>str</code>)</li> </ul>"},{"location":"reference/ipr/types/#class-iprgene","title":"class IprGene","text":"<p>inherits <code>TypedDict</code></p> <p>Attributes</p> <ul> <li>name (<code>str</code>)</li> <li>cancerRelated (<code>Optional[bool]</code>)</li> <li>knownFusionPartner (<code>Optional[bool]</code>)</li> <li>knownSmallMutation (<code>Optional[bool]</code>)</li> <li>tumourSuppressor (<code>Optional[bool]</code>)</li> <li>oncogene (<code>Optional[bool]</code>)</li> <li>therapeuticAssociated (<code>Optional[bool]</code>)</li> </ul>"},{"location":"reference/ipr/types/#class-iprvariantbase","title":"class IprVariantBase","text":"<p>inherits <code>TypedDict</code></p> <p>Required properties of all variants for IPR.</p> <p>Attributes</p> <ul> <li>key (<code>str</code>)</li> <li>variantType (<code>str</code>)</li> <li>variant (<code>str</code>)</li> </ul>"},{"location":"reference/ipr/types/#class-iprgenevariant","title":"class IprGeneVariant","text":"<p>inherits IprVariantBase</p> <p>Attributes</p> <ul> <li>gene (<code>str</code>)</li> </ul>"},{"location":"reference/ipr/types/#class-iprcopyvariant","title":"class IprCopyVariant","text":"<p>inherits IprGeneVariant</p> <p>Attributes</p> <ul> <li>kbCategory (<code>str</code>)</li> <li>cnvState (<code>str</code>)</li> </ul>"},{"location":"reference/ipr/types/#class-iprexprvariant","title":"class IprExprVariant","text":"<p>inherits IprGeneVariant</p> <p>Attributes</p> <ul> <li>kbCategory (<code>str</code>)</li> <li>expressionState (<code>str</code>)</li> <li>histogramImage (<code>Optional[str]</code>)</li> </ul>"},{"location":"reference/ipr/types/#class-iprstructvarbase","title":"class IprStructVarBase","text":"<p>inherits IprVariantBase</p> <p>One of the hgvs notations or proteinChange is required.</p> <p>Attributes</p> <ul> <li>hgvsProtein (<code>Optional[str]</code>)</li> <li>hgvsCds (<code>Optional[str]</code>)</li> <li>hgvsGenomic (<code>Optional[str]</code>)</li> <li>proteinChange (<code>Optional[str]</code>)</li> </ul>"},{"location":"reference/ipr/types/#class-iprsmallmutationvariant","title":"class IprSmallMutationVariant","text":"<p>inherits IprStructVarBase</p> <p>SNPs and small INDELs</p> <p>Attributes</p> <ul> <li>gene (<code>str</code>)</li> <li>germline (<code>Optional[bool]</code>)</li> <li>startPosition (<code>Optional[int]</code>)</li> <li>endPosition (<code>Optional[int]</code>)</li> <li>normalAltCount (<code>Optional[int]</code>)</li> <li>normalDepth (<code>Optional[int]</code>)</li> <li>normalRefCount (<code>Optional[int]</code>)</li> <li>rnaAltCount (<code>Optional[int]</code>)</li> <li>rnaDepth (<code>Optional[int]</code>)</li> <li>rnaRefCount (<code>Optional[int]</code>)</li> <li>tumourAltCount (<code>Optional[int]</code>)</li> <li>tumourDepth (<code>Optional[int]</code>)</li> <li>tumourRefCount (<code>Optional[int]</code>)</li> </ul>"},{"location":"reference/ipr/types/#class-iprfusionvariant","title":"class IprFusionVariant","text":"<p>inherits IprStructVarBase</p> <p>Attributes</p> <ul> <li>gene1 (<code>str</code>)</li> <li>gene2 (<code>str</code>)</li> <li>exon1 (<code>int</code>)</li> <li>exon2 (<code>int</code>)</li> <li>highQuality (<code>Optional[bool]</code>)</li> <li>svg (<code>Optional[str]</code>)</li> </ul>"},{"location":"reference/ipr/types/#class-imagedefinition","title":"class ImageDefinition","text":"<p>inherits <code>TypedDict</code></p> <p>Attributes</p> <ul> <li>key (<code>str</code>)</li> <li>path (<code>str</code>)</li> </ul>"},{"location":"reference/ipr/types/#class-gkbstatement","title":"class GkbStatement","text":"<p>inherits <code>Record</code></p> <p>No 'links' handled.</p> <p>Attributes</p> <ul> <li>relevance (<code>Ontology</code>)</li> <li>subject (<code>Ontology</code>)</li> <li>conditions (<code>List[Ontology]</code>)</li> <li>evidence (<code>List[Ontology]</code>)</li> <li>evidenceLevel (<code>List[Ontology]</code>)</li> <li>source (<code>Record</code>)</li> <li>sourceId (<code>str</code>)</li> <li>reviewStatus (<code>Optional[str]</code>)</li> <li>displayNameTemplate (<code>str</code>)</li> </ul>"},{"location":"reference/ipr/util/","title":"ipr/util","text":""},{"location":"reference/ipr/util/#gene_neighbors_max","title":"GENE_NEIGHBORS_MAX","text":"<pre><code>GENE_NEIGHBORS_MAX = 3\n</code></pre>"},{"location":"reference/ipr/util/#logger","title":"logger","text":"<pre><code>logger = logging.getLogger('ipr')\n</code></pre>"},{"location":"reference/ipr/util/#log_levels","title":"LOG_LEVELS","text":"<pre><code>LOG_LEVELS = {\n    'info': logging.INFO,\n    'debug': logging.DEBUG,\n    'warn': logging.WARN,\n    'error': logging.ERROR,\n</code></pre>"},{"location":"reference/ipr/util/#class-hashabledict","title":"class Hashabledict","text":"<p>inherits <code>dict</code></p>"},{"location":"reference/ipr/util/#create_variant_name_tuple","title":"create_variant_name_tuple()","text":"<p>Given an IPR variant row, create the variant representation to be used as the name of the variant</p> <pre><code>def create_variant_name_tuple(variant: IprVariant) -&gt; Tuple[str, str]:\n</code></pre> <p>Args</p> <ul> <li>variant (IprVariant)</li> </ul> <p>Returns</p> <ul> <li><code>Tuple[str, str]</code></li> </ul>"},{"location":"reference/ipr/util/#find_variant","title":"find_variant()","text":"<p>Find a variant in a list of variants by its key and type</p> <pre><code>def find_variant(\n    all_variants: Sequence[IprVariant], variant_type: str, variant_key: str\n) -&gt; IprVariant:\n</code></pre> <p>Args</p> <ul> <li>all_variants (Sequence[IprVariant])</li> <li>variant_type (<code>str</code>)</li> <li>variant_key (<code>str</code>)</li> </ul> <p>Returns</p> <ul> <li>IprVariant</li> </ul>"},{"location":"reference/ipr/util/#generate_ontology_preference_key","title":"generate_ontology_preference_key()","text":"<p>Generate a tuple key for comparing preferred ontology terms.</p> <pre><code>def generate_ontology_preference_key(record: Ontology, sources_sort: Dict[str, int] = {}) -&gt; Tuple:\n</code></pre> <p>Args</p> <ul> <li>record (<code>Ontology</code>)</li> <li>sources_sort (<code>Dict[str, int]</code>)</li> </ul> <p>Returns</p> <ul> <li><code>Tuple</code></li> </ul>"},{"location":"reference/ipr/util/#get_preferred_drug_representation","title":"get_preferred_drug_representation()","text":"<p>Given a Drug record, follow its linked records to find the preferred representation by following alias, deprecating, and cross reference links.</p> <pre><code>def get_preferred_drug_representation(\n    graphkb_conn: GraphKBConnection, drug_record_id: str\n) -&gt; Ontology:\n</code></pre> <p>Args</p> <ul> <li>graphkb_conn (<code>GraphKBConnection</code>)</li> <li>drug_record_id (<code>str</code>)</li> </ul> <p>Returns</p> <ul> <li><code>Ontology</code></li> </ul>"},{"location":"reference/ipr/util/#get_preferred_gene_name","title":"get_preferred_gene_name()","text":"<p>Given some Feature record ID return the preferred gene name.</p> <pre><code>def get_preferred_gene_name(\n    graphkb_conn: GraphKBConnection, record_id: str, neighbors: int = GENE_NEIGHBORS_MAX\n) -&gt; str:\n</code></pre> <p>Args</p> <ul> <li>graphkb_conn (<code>GraphKBConnection</code>)</li> <li>record_id (<code>str</code>)</li> <li>neighbors (<code>int</code>)</li> </ul> <p>Returns</p> <ul> <li><code>str</code></li> </ul>"},{"location":"reference/ipr/util/#pandas_falsy","title":"pandas_falsy()","text":"<p>Check if a field is python falsy or pandas null.</p> <pre><code>def pandas_falsy(field: Any) -&gt; bool:\n</code></pre> <p>Args</p> <ul> <li>field (<code>Any</code>)</li> </ul> <p>Returns</p> <ul> <li><code>bool</code></li> </ul>"}]}