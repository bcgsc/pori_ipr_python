{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Notice Documentation for this tool has been moved to the centralized PORI documentation","title":"Notice"},{"location":"#notice","text":"Documentation for this tool has been moved to the centralized PORI documentation","title":"Notice"},{"location":"reference/ipr/annotate/","text":"ipr/annotate handles annotating variants with annotation information from graphkb get_gene_information() Create the Gene Info object for upload to IPR with the other report information def get_gene_information( graphkb_conn: GraphKBConnection, gene_names: Iterable[str] ) -> List[IprGene]: Args graphkb_conn ( GraphKBConnection ): [description] gene_names ( Iterable[str] ): [description] Returns List[ IprGene ] get_statements_from_variants() Given a list of variant records from GraphKB, return all the related statements def get_statements_from_variants( graphkb_conn: GraphKBConnection, variants: List[Record] ) -> List[Statement]: Args graphkb_conn ( GraphKBConnection ): the graphkb api connection object variants ( List[Record] ): list of variant records Returns List[Statement] : list of Statement records from graphkb get_second_pass_variants() Given a list of statements that have been matched. Convert these to new category variants to be used in a second-pass matching def get_second_pass_variants( graphkb_conn: GraphKBConnection, statements: List[Statement] ) -> List[Variant]: Args graphkb_conn ( GraphKBConnection ) statements ( List[Statement] ) Returns List[Variant] get_ipr_statements_from_variants() Matches to GraphKB statements from the list of input variants. From these results matches again with the inferred variants. Then returns the results formatted for upload to IPR def get_ipr_statements_from_variants( graphkb_conn: GraphKBConnection, matches: List[Record], disease_name: str ) -> List[KbMatch]: Args graphkb_conn ( GraphKBConnection ) matches ( List[Record] ) disease_name ( str ) Returns List[ KbMatch ] annotate_category_variants() Annotate variant calls with information from GraphKB and return these annotations in the IPR alterations format def annotate_category_variants( graphkb_conn: GraphKBConnection, variants: List[IprGeneVariant], disease_name: str, copy_variant: bool = True, show_progress: bool = False, ) -> List[KbMatch]: Args graphkb_conn ( GraphKBConnection ): the graphkb api connection object variants (List[ IprGeneVariant ]): list of variants disease_name ( str ) copy_variant ( bool ) show_progress ( bool ) Returns List[ KbMatch ]: list of kbMatches records for IPR annotate_positional_variants() Annotate variant calls with information from GraphKB and return these annotations in the IPR alterations format def annotate_positional_variants( graphkb_conn: GraphKBConnection, variants: List[IprVariant], disease_name: str, show_progress: bool = False, ) -> List[KbMatch]: Args graphkb_conn ( GraphKBConnection ): the graphkb api connection object variants (List[ IprVariant ]): list of variants. Defaults to []. disease_name ( str ) show_progress ( bool ) Returns List[ KbMatch ]: list of kbMatches records for IPR","title":"ipr/annotate"},{"location":"reference/ipr/annotate/#iprannotate","text":"handles annotating variants with annotation information from graphkb","title":"ipr/annotate"},{"location":"reference/ipr/annotate/#get_gene_information","text":"Create the Gene Info object for upload to IPR with the other report information def get_gene_information( graphkb_conn: GraphKBConnection, gene_names: Iterable[str] ) -> List[IprGene]: Args graphkb_conn ( GraphKBConnection ): [description] gene_names ( Iterable[str] ): [description] Returns List[ IprGene ]","title":"get_gene_information()"},{"location":"reference/ipr/annotate/#get_statements_from_variants","text":"Given a list of variant records from GraphKB, return all the related statements def get_statements_from_variants( graphkb_conn: GraphKBConnection, variants: List[Record] ) -> List[Statement]: Args graphkb_conn ( GraphKBConnection ): the graphkb api connection object variants ( List[Record] ): list of variant records Returns List[Statement] : list of Statement records from graphkb","title":"get_statements_from_variants()"},{"location":"reference/ipr/annotate/#get_second_pass_variants","text":"Given a list of statements that have been matched. Convert these to new category variants to be used in a second-pass matching def get_second_pass_variants( graphkb_conn: GraphKBConnection, statements: List[Statement] ) -> List[Variant]: Args graphkb_conn ( GraphKBConnection ) statements ( List[Statement] ) Returns List[Variant]","title":"get_second_pass_variants()"},{"location":"reference/ipr/annotate/#get_ipr_statements_from_variants","text":"Matches to GraphKB statements from the list of input variants. From these results matches again with the inferred variants. Then returns the results formatted for upload to IPR def get_ipr_statements_from_variants( graphkb_conn: GraphKBConnection, matches: List[Record], disease_name: str ) -> List[KbMatch]: Args graphkb_conn ( GraphKBConnection ) matches ( List[Record] ) disease_name ( str ) Returns List[ KbMatch ]","title":"get_ipr_statements_from_variants()"},{"location":"reference/ipr/annotate/#annotate_category_variants","text":"Annotate variant calls with information from GraphKB and return these annotations in the IPR alterations format def annotate_category_variants( graphkb_conn: GraphKBConnection, variants: List[IprGeneVariant], disease_name: str, copy_variant: bool = True, show_progress: bool = False, ) -> List[KbMatch]: Args graphkb_conn ( GraphKBConnection ): the graphkb api connection object variants (List[ IprGeneVariant ]): list of variants disease_name ( str ) copy_variant ( bool ) show_progress ( bool ) Returns List[ KbMatch ]: list of kbMatches records for IPR","title":"annotate_category_variants()"},{"location":"reference/ipr/annotate/#annotate_positional_variants","text":"Annotate variant calls with information from GraphKB and return these annotations in the IPR alterations format def annotate_positional_variants( graphkb_conn: GraphKBConnection, variants: List[IprVariant], disease_name: str, show_progress: bool = False, ) -> List[KbMatch]: Args graphkb_conn ( GraphKBConnection ): the graphkb api connection object variants (List[ IprVariant ]): list of variants. Defaults to []. disease_name ( str ) show_progress ( bool ) Returns List[ KbMatch ]: list of kbMatches records for IPR","title":"annotate_positional_variants()"},{"location":"reference/ipr/connection/","text":"ipr/connection IMAGE_MAX IMAGE_MAX = 20 # cannot upload more than 20 images at a time class IprConnection IprConnection.request() Request wrapper to handle adding common headers and logging def request(self, endpoint: str, method: str = 'GET', **kwargs) -> Dict: Args endpoint ( str ): api endpoint, excluding the base uri method ( str ): the http method. Defaults to 'GET'. Returns Dict : the json response as a python dict IprConnection.post() Convenience method for making post requests def post(self, uri: str, data: Dict = {}, **kwargs) -> Dict: Args uri ( str ) data ( Dict ) Returns Dict IprConnection.set_analyst_comments() Update report comments to an existing report def set_analyst_comments(self, report_id: str, data: Dict) -> Dict: Args report_id ( str ) data ( Dict ) Returns Dict !!! todo Add to main upload. Pending: https://www.bcgsc.ca/jira/browse/DEVSU-1177 IprConnection.post_images() Post images to the report def post_images(self, report_id: str, files: Dict[str, str], data: Dict[str, str] = {}) -> None: Args report_id ( str ) files ( Dict[str, str] ) data ( Dict[str, str] )","title":"ipr/connection"},{"location":"reference/ipr/connection/#iprconnection","text":"","title":"ipr/connection"},{"location":"reference/ipr/connection/#image_max","text":"IMAGE_MAX = 20 # cannot upload more than 20 images at a time","title":"IMAGE_MAX"},{"location":"reference/ipr/connection/#class-iprconnection","text":"","title":"class IprConnection"},{"location":"reference/ipr/connection/#iprconnectionrequest","text":"Request wrapper to handle adding common headers and logging def request(self, endpoint: str, method: str = 'GET', **kwargs) -> Dict: Args endpoint ( str ): api endpoint, excluding the base uri method ( str ): the http method. Defaults to 'GET'. Returns Dict : the json response as a python dict","title":"IprConnection.request()"},{"location":"reference/ipr/connection/#iprconnectionpost","text":"Convenience method for making post requests def post(self, uri: str, data: Dict = {}, **kwargs) -> Dict: Args uri ( str ) data ( Dict ) Returns Dict","title":"IprConnection.post()"},{"location":"reference/ipr/connection/#iprconnectionset_analyst_comments","text":"Update report comments to an existing report def set_analyst_comments(self, report_id: str, data: Dict) -> Dict: Args report_id ( str ) data ( Dict ) Returns Dict !!! todo Add to main upload. Pending: https://www.bcgsc.ca/jira/browse/DEVSU-1177","title":"IprConnection.set_analyst_comments()"},{"location":"reference/ipr/connection/#iprconnectionpost_images","text":"Post images to the report def post_images(self, report_id: str, files: Dict[str, str], data: Dict[str, str] = {}) -> None: Args report_id ( str ) files ( Dict[str, str] ) data ( Dict[str, str] )","title":"IprConnection.post_images()"},{"location":"reference/ipr/inputs/","text":"ipr/inputs Read/Validate the variant input files SPECIFICATION SPECIFICATION = os.path.join(os.path.dirname(__file__), 'content.spec.json') COPY_REQ COPY_REQ = ['gene', 'kbCategory'] COPY_KEY COPY_KEY = ['gene'] COPY_OPTIONAL COPY_OPTIONAL = [ 'cnvState', 'copyChange', 'lohState', # Loss of Heterzygosity state - informative detail to analyst 'chromosomeBand', 'start', 'end', 'size', 'log2Cna', 'cna', ] SMALL_MUT_REQ SMALL_MUT_REQ = ['gene', 'proteinChange'] SMALL_MUT_KEY SMALL_MUT_KEY = SMALL_MUT_REQ + [ 'altSeq', 'chromosome', 'endPosition', 'refSeq', 'startPosition', 'transcript', SMALL_MUT_OPTIONAL SMALL_MUT_OPTIONAL = [ 'altSeq', 'chromosome', 'endPosition', 'germline', 'hgvsCds', 'hgvsGenomic', 'hgvsProtein', 'ncbiBuild', 'normalAltCount', 'normalDepth', 'normalRefCount', 'refSeq', 'rnaAltCount', 'rnaDepth', 'rnaRefCount', 'startPosition', 'transcript', 'tumourAltCount', 'tumourDepth', 'tumourRefCount', 'zygosity', ] EXP_REQ EXP_REQ = ['gene', 'kbCategory'] EXP_KEY EXP_KEY = ['gene'] EXP_OPTIONAL EXP_OPTIONAL = [ 'biopsySiteFoldChange', 'biopsySitePercentile', 'biopsySiteQC', 'biopsySiteZScore', 'biopsySitekIQR', 'diseaseFoldChange', 'diseasekIQR', 'diseasePercentile', 'diseaseQC', 'diseaseZScore', 'expressionState', 'histogramImage', 'primarySiteFoldChange', 'primarySitekIQR', 'primarySitePercentile', 'primarySiteQC', 'primarySiteZScore', 'rnaReads', 'rpkm', 'tpm', ] SV_REQ SV_REQ = [ 'eventType', 'breakpoint', 'gene1', # prev: nterm_hugo 'gene2', # prev: cterm_hugo 'exon1', # n-terminal 'exon2', # c-terminal ] SV_KEY SV_KEY = SV_REQ[:] SV_OPTIONAL SV_OPTIONAL = [ 'ctermTranscript', 'ntermTranscript', 'ctermGene', # combined hugo ensembl form 'ntermGene', # combined hugo ensembl form 'detectedIn', 'conventionalName', 'svg', 'svgTitle', 'name', 'frame', 'omicSupport', 'highQuality', ] DefaultValidatingDraft7Validator DefaultValidatingDraft7Validator = extend_with_default(jsonschema.Draft7Validator) validate_variant_rows() check that the required columns are present check that a unique key can be formed for each row drop any non-defined columns def validate_variant_rows( rows: Iterable[Dict], required: List[str], optional: List[str], row_to_key: Callable ) -> List[IprVariant]: Args rows ( Iterable[Dict] ): the input files rows required ( List[str] ) optional ( List[str] ): list of optional column names row_to_key ( Callable ): function to generate a key for a given row Returns List[ IprVariant ]: the rows from the tab file as dictionaries Raises ValueError : row keys are not unique ValueError : A required column is missing preprocess_copy_variants() Validate the input rows contain the minimum required fields and generate any default values where possible def preprocess_copy_variants(rows: Iterable[Dict]) -> List[IprVariant]: Args rows ( Iterable[Dict] ) Returns List[ IprVariant ] preprocess_small_mutations() Validate the input rows contain the minimum required fields and generate any default values where possible def preprocess_small_mutations(rows: Iterable[Dict]) -> List[IprGeneVariant]: Args rows ( Iterable[Dict] ) Returns List[ IprGeneVariant ] preprocess_expression_variants() Validate the input rows contain the minimum required fields and generate any default values where possible def preprocess_expression_variants(rows: Iterable[Dict]) -> List[IprGeneVariant]: Args rows ( Iterable[Dict] ) Returns List[ IprGeneVariant ] create_graphkb_sv_notation() Generate GKB style structural variant notation from a structural variant input row def create_graphkb_sv_notation(row: IprStructuralVariant) -> str: Args row ( IprStructuralVariant ) Returns str preprocess_structural_variants() Validate the input rows contain the minimum required fields and generate any default values where possible def preprocess_structural_variants(rows: Iterable[Dict]) -> List[IprVariant]: Args rows ( Iterable[Dict] ) Returns List[ IprVariant ] check_variant_links() Check matching information for any genes with variants. Warn about genes with only one experimental measure. def check_variant_links( small_mutations: List[IprGeneVariant], expression_variants: List[IprGeneVariant], copy_variants: List[IprGeneVariant], structural_variants: List[IprStructuralVariant], ) -> Set[str]: Args small_mutations (List[ IprGeneVariant ]): list of small mutations expression_variants (List[ IprGeneVariant ]): list of expression variants copy_variants (List[ IprGeneVariant ]): list of copy variants structural_variants (List[ IprStructuralVariant ]): list of structural variants Returns Set[str] : set of gene names with variants (used for filtering before upload to IPR) check_comparators() Given the optional content dictionary, check that based on the analyses present the correct/sufficient comparators have also been specified def check_comparators(content: Dict, expresssionVariants: Iterable[Dict] = []) -> None: Args content ( Dict ) expresssionVariants ( Iterable[Dict] ) validate_report_content() Validate a report content input JSON object against the schema specification Adds defaults as reccommended by: https://python-jsonschema.readthedocs.io/en/latest/faq/#why-doesn-t-my-schema-s-default-property-set-the-default-on-my-instance def validate_report_content(content: Dict, schema_file: str = SPECIFICATION) -> None: Args content ( Dict ) schema_file ( str )","title":"ipr/inputs"},{"location":"reference/ipr/inputs/#iprinputs","text":"Read/Validate the variant input files","title":"ipr/inputs"},{"location":"reference/ipr/inputs/#specification","text":"SPECIFICATION = os.path.join(os.path.dirname(__file__), 'content.spec.json')","title":"SPECIFICATION"},{"location":"reference/ipr/inputs/#copy_req","text":"COPY_REQ = ['gene', 'kbCategory']","title":"COPY_REQ"},{"location":"reference/ipr/inputs/#copy_key","text":"COPY_KEY = ['gene']","title":"COPY_KEY"},{"location":"reference/ipr/inputs/#copy_optional","text":"COPY_OPTIONAL = [ 'cnvState', 'copyChange', 'lohState', # Loss of Heterzygosity state - informative detail to analyst 'chromosomeBand', 'start', 'end', 'size', 'log2Cna', 'cna', ]","title":"COPY_OPTIONAL"},{"location":"reference/ipr/inputs/#small_mut_req","text":"SMALL_MUT_REQ = ['gene', 'proteinChange']","title":"SMALL_MUT_REQ"},{"location":"reference/ipr/inputs/#small_mut_key","text":"SMALL_MUT_KEY = SMALL_MUT_REQ + [ 'altSeq', 'chromosome', 'endPosition', 'refSeq', 'startPosition', 'transcript',","title":"SMALL_MUT_KEY"},{"location":"reference/ipr/inputs/#small_mut_optional","text":"SMALL_MUT_OPTIONAL = [ 'altSeq', 'chromosome', 'endPosition', 'germline', 'hgvsCds', 'hgvsGenomic', 'hgvsProtein', 'ncbiBuild', 'normalAltCount', 'normalDepth', 'normalRefCount', 'refSeq', 'rnaAltCount', 'rnaDepth', 'rnaRefCount', 'startPosition', 'transcript', 'tumourAltCount', 'tumourDepth', 'tumourRefCount', 'zygosity', ]","title":"SMALL_MUT_OPTIONAL"},{"location":"reference/ipr/inputs/#exp_req","text":"EXP_REQ = ['gene', 'kbCategory']","title":"EXP_REQ"},{"location":"reference/ipr/inputs/#exp_key","text":"EXP_KEY = ['gene']","title":"EXP_KEY"},{"location":"reference/ipr/inputs/#exp_optional","text":"EXP_OPTIONAL = [ 'biopsySiteFoldChange', 'biopsySitePercentile', 'biopsySiteQC', 'biopsySiteZScore', 'biopsySitekIQR', 'diseaseFoldChange', 'diseasekIQR', 'diseasePercentile', 'diseaseQC', 'diseaseZScore', 'expressionState', 'histogramImage', 'primarySiteFoldChange', 'primarySitekIQR', 'primarySitePercentile', 'primarySiteQC', 'primarySiteZScore', 'rnaReads', 'rpkm', 'tpm', ]","title":"EXP_OPTIONAL"},{"location":"reference/ipr/inputs/#sv_req","text":"SV_REQ = [ 'eventType', 'breakpoint', 'gene1', # prev: nterm_hugo 'gene2', # prev: cterm_hugo 'exon1', # n-terminal 'exon2', # c-terminal ]","title":"SV_REQ"},{"location":"reference/ipr/inputs/#sv_key","text":"SV_KEY = SV_REQ[:]","title":"SV_KEY"},{"location":"reference/ipr/inputs/#sv_optional","text":"SV_OPTIONAL = [ 'ctermTranscript', 'ntermTranscript', 'ctermGene', # combined hugo ensembl form 'ntermGene', # combined hugo ensembl form 'detectedIn', 'conventionalName', 'svg', 'svgTitle', 'name', 'frame', 'omicSupport', 'highQuality', ]","title":"SV_OPTIONAL"},{"location":"reference/ipr/inputs/#defaultvalidatingdraft7validator","text":"DefaultValidatingDraft7Validator = extend_with_default(jsonschema.Draft7Validator)","title":"DefaultValidatingDraft7Validator"},{"location":"reference/ipr/inputs/#validate_variant_rows","text":"check that the required columns are present check that a unique key can be formed for each row drop any non-defined columns def validate_variant_rows( rows: Iterable[Dict], required: List[str], optional: List[str], row_to_key: Callable ) -> List[IprVariant]: Args rows ( Iterable[Dict] ): the input files rows required ( List[str] ) optional ( List[str] ): list of optional column names row_to_key ( Callable ): function to generate a key for a given row Returns List[ IprVariant ]: the rows from the tab file as dictionaries Raises ValueError : row keys are not unique ValueError : A required column is missing","title":"validate_variant_rows()"},{"location":"reference/ipr/inputs/#preprocess_copy_variants","text":"Validate the input rows contain the minimum required fields and generate any default values where possible def preprocess_copy_variants(rows: Iterable[Dict]) -> List[IprVariant]: Args rows ( Iterable[Dict] ) Returns List[ IprVariant ]","title":"preprocess_copy_variants()"},{"location":"reference/ipr/inputs/#preprocess_small_mutations","text":"Validate the input rows contain the minimum required fields and generate any default values where possible def preprocess_small_mutations(rows: Iterable[Dict]) -> List[IprGeneVariant]: Args rows ( Iterable[Dict] ) Returns List[ IprGeneVariant ]","title":"preprocess_small_mutations()"},{"location":"reference/ipr/inputs/#preprocess_expression_variants","text":"Validate the input rows contain the minimum required fields and generate any default values where possible def preprocess_expression_variants(rows: Iterable[Dict]) -> List[IprGeneVariant]: Args rows ( Iterable[Dict] ) Returns List[ IprGeneVariant ]","title":"preprocess_expression_variants()"},{"location":"reference/ipr/inputs/#create_graphkb_sv_notation","text":"Generate GKB style structural variant notation from a structural variant input row def create_graphkb_sv_notation(row: IprStructuralVariant) -> str: Args row ( IprStructuralVariant ) Returns str","title":"create_graphkb_sv_notation()"},{"location":"reference/ipr/inputs/#preprocess_structural_variants","text":"Validate the input rows contain the minimum required fields and generate any default values where possible def preprocess_structural_variants(rows: Iterable[Dict]) -> List[IprVariant]: Args rows ( Iterable[Dict] ) Returns List[ IprVariant ]","title":"preprocess_structural_variants()"},{"location":"reference/ipr/inputs/#check_variant_links","text":"Check matching information for any genes with variants. Warn about genes with only one experimental measure. def check_variant_links( small_mutations: List[IprGeneVariant], expression_variants: List[IprGeneVariant], copy_variants: List[IprGeneVariant], structural_variants: List[IprStructuralVariant], ) -> Set[str]: Args small_mutations (List[ IprGeneVariant ]): list of small mutations expression_variants (List[ IprGeneVariant ]): list of expression variants copy_variants (List[ IprGeneVariant ]): list of copy variants structural_variants (List[ IprStructuralVariant ]): list of structural variants Returns Set[str] : set of gene names with variants (used for filtering before upload to IPR)","title":"check_variant_links()"},{"location":"reference/ipr/inputs/#check_comparators","text":"Given the optional content dictionary, check that based on the analyses present the correct/sufficient comparators have also been specified def check_comparators(content: Dict, expresssionVariants: Iterable[Dict] = []) -> None: Args content ( Dict ) expresssionVariants ( Iterable[Dict] )","title":"check_comparators()"},{"location":"reference/ipr/inputs/#validate_report_content","text":"Validate a report content input JSON object against the schema specification Adds defaults as reccommended by: https://python-jsonschema.readthedocs.io/en/latest/faq/#why-doesn-t-my-schema-s-default-property-set-the-default-on-my-instance def validate_report_content(content: Dict, schema_file: str = SPECIFICATION) -> None: Args content ( Dict ) schema_file ( str )","title":"validate_report_content()"},{"location":"reference/ipr/ipr/","text":"ipr/ipr Contains functions specific to formatting reports for IPR that are unlikely to be used by other reporting systems filter_structural_variants() Filter structural variants to remove non-high quality events unless they are matched/annotated or they involve a gene that is a known fusion partner def filter_structural_variants( structural_variants: List[IprStructuralVariant], kb_matches: List[KbMatch], gene_annotations: List[IprGene], ) -> List[IprStructuralVariant]: Args structural_variants (List[ IprStructuralVariant ]) kb_matches (List[ KbMatch ]) gene_annotations (List[ IprGene ]) Returns List[ IprStructuralVariant ] convert_statements_to_alterations() Given a set of statements matched from graphkb, convert these into their IPR equivalent representations def convert_statements_to_alterations( graphkb_conn: GraphKBConnection, statements: List[Statement], disease_name: str, variant_matches: Iterable[str], ) -> List[KbMatch]: Args graphkb_conn ( GraphKBConnection ): the graphkb connection object statements ( List[Statement] ): list of statement records from graphkb disease_name ( str ): name of the cancer type for the patient being reported on variant_matches ( Iterable[str] ): the list of RIDs the variant matched for these statements Returns List[ KbMatch ]: IPR graphkb row representations Notes: - only report disease matched prognostic markers https://www.bcgsc.ca/jira/browse/GERO-72 and GERO-196 Raises ValueError : could not find the disease type in GraphKB select_expression_plots() Given the list of expression variants, determine which expression historgram plots should be included in the IPR upload. This filters them based on the graphkb annotations to avoid loading more images than are required def select_expression_plots( kb_matches: List[KbMatch], all_variants: List[IprVariant] ) -> List[Dict[str, ImageDefinition]]: Args kb_matches (List[ KbMatch ]): the IPR graphkb annoations for all variants all_variants (List[ IprVariant ]) Returns List[Dict[ str , ImageDefinition ]]: list of expression images to be loaded by IPR create_key_alterations() Creates the list of genomic key alterations which summarizes all the variants matched by the KB This list of matches is also used to create the variant counts def create_key_alterations( kb_matches: List[KbMatch], all_variants: List[IprVariant] ) -> Tuple[List[Dict], Dict]: Args kb_matches (List[ KbMatch ]) all_variants (List[ IprVariant ]) Returns Tuple[List[Dict], Dict] germline_kb_matches() Filter kb_matches for matching to germline or somatic events using the 'germline' optional property. Statements related to pharmacogenomic toxicity or cancer predisposition are only relevant if the variant is present in the germline of the patient. Other statements, such as diagnostic or recurrent oncogenic mutations, are only relevant as somatic events in cancer. Germline variants are excluded from these matches. Params: kb_matches: KbMatch statements to be filtered. 'variant' properties must match 'key' in all_variants. all_variants: IprVariants, with a 'germline' property, that were used for kb_matches creation. assume_somatic: Whether to assume somatic or germline when no 'germline' property exists in the variant. def germline_kb_matches( kb_matches: List[KbMatch], all_variants: List[IprVariant], assume_somatic: bool = True ) -> List[KbMatch]: Args kb_matches (List[ KbMatch ]) all_variants (List[ IprVariant ]) assume_somatic ( bool ) Returns List[ KbMatch ]: filtered list of kb_matches","title":"ipr/ipr"},{"location":"reference/ipr/ipr/#ipripr","text":"Contains functions specific to formatting reports for IPR that are unlikely to be used by other reporting systems","title":"ipr/ipr"},{"location":"reference/ipr/ipr/#filter_structural_variants","text":"Filter structural variants to remove non-high quality events unless they are matched/annotated or they involve a gene that is a known fusion partner def filter_structural_variants( structural_variants: List[IprStructuralVariant], kb_matches: List[KbMatch], gene_annotations: List[IprGene], ) -> List[IprStructuralVariant]: Args structural_variants (List[ IprStructuralVariant ]) kb_matches (List[ KbMatch ]) gene_annotations (List[ IprGene ]) Returns List[ IprStructuralVariant ]","title":"filter_structural_variants()"},{"location":"reference/ipr/ipr/#convert_statements_to_alterations","text":"Given a set of statements matched from graphkb, convert these into their IPR equivalent representations def convert_statements_to_alterations( graphkb_conn: GraphKBConnection, statements: List[Statement], disease_name: str, variant_matches: Iterable[str], ) -> List[KbMatch]: Args graphkb_conn ( GraphKBConnection ): the graphkb connection object statements ( List[Statement] ): list of statement records from graphkb disease_name ( str ): name of the cancer type for the patient being reported on variant_matches ( Iterable[str] ): the list of RIDs the variant matched for these statements Returns List[ KbMatch ]: IPR graphkb row representations Notes: - only report disease matched prognostic markers https://www.bcgsc.ca/jira/browse/GERO-72 and GERO-196 Raises ValueError : could not find the disease type in GraphKB","title":"convert_statements_to_alterations()"},{"location":"reference/ipr/ipr/#select_expression_plots","text":"Given the list of expression variants, determine which expression historgram plots should be included in the IPR upload. This filters them based on the graphkb annotations to avoid loading more images than are required def select_expression_plots( kb_matches: List[KbMatch], all_variants: List[IprVariant] ) -> List[Dict[str, ImageDefinition]]: Args kb_matches (List[ KbMatch ]): the IPR graphkb annoations for all variants all_variants (List[ IprVariant ]) Returns List[Dict[ str , ImageDefinition ]]: list of expression images to be loaded by IPR","title":"select_expression_plots()"},{"location":"reference/ipr/ipr/#create_key_alterations","text":"Creates the list of genomic key alterations which summarizes all the variants matched by the KB This list of matches is also used to create the variant counts def create_key_alterations( kb_matches: List[KbMatch], all_variants: List[IprVariant] ) -> Tuple[List[Dict], Dict]: Args kb_matches (List[ KbMatch ]) all_variants (List[ IprVariant ]) Returns Tuple[List[Dict], Dict]","title":"create_key_alterations()"},{"location":"reference/ipr/ipr/#germline_kb_matches","text":"Filter kb_matches for matching to germline or somatic events using the 'germline' optional property. Statements related to pharmacogenomic toxicity or cancer predisposition are only relevant if the variant is present in the germline of the patient. Other statements, such as diagnostic or recurrent oncogenic mutations, are only relevant as somatic events in cancer. Germline variants are excluded from these matches. Params: kb_matches: KbMatch statements to be filtered. 'variant' properties must match 'key' in all_variants. all_variants: IprVariants, with a 'germline' property, that were used for kb_matches creation. assume_somatic: Whether to assume somatic or germline when no 'germline' property exists in the variant. def germline_kb_matches( kb_matches: List[KbMatch], all_variants: List[IprVariant], assume_somatic: bool = True ) -> List[KbMatch]: Args kb_matches (List[ KbMatch ]) all_variants (List[ IprVariant ]) assume_somatic ( bool ) Returns List[ KbMatch ]: filtered list of kb_matches","title":"germline_kb_matches()"},{"location":"reference/ipr/main/","text":"ipr/main CACHE_GENE_MINIMUM CACHE_GENE_MINIMUM = 5000 clean_unsupported_content() Remove unsupported content. This content is either added to facilitate creation or to support upcoming and soon to be supported content that we would like to implement but is not yet supported by the upload def clean_unsupported_content(upload_content: Dict) -> Dict: Args upload_content ( Dict ) Returns Dict create_report() Run the matching and create the report JSON for upload to IPR def create_report( username: str, password: str, content: Dict, ipr_url: str = DEFAULT_URL, log_level: str = 'info', output_json_path: str = None, always_write_output_json: bool = False, ipr_upload: bool = True, interactive: bool = False, graphkb_url: str = '', generate_therapeutics: bool = False, generate_comments: bool = True, match_germline: bool = False, custom_kb_match_filter=None, ) -> Dict: Args username ( str ): the username for connecting to GraphKB and IPR password ( str ): the password for connecting to GraphKB and IPR content ( Dict ): report content ipr_url ( str ): base URL to use in connecting to IPR log_level ( str ): the logging level output_json_path ( str ): path to a JSON file to output the report upload body. always_write_output_json ( bool ): with successful IPR upload ipr_upload ( bool ): upload report to ipr interactive ( bool ): progressbars for interactive users graphkb_url ( str ) generate_therapeutics ( bool ): create therapeutic options for upload with the report generate_comments ( bool ): create the analyst comments section for upload with the report match_germline ( bool ): match only germline statements to germline events and non-germline statements to non-germline events. custom_kb_match_filter: function(List[kbMatch]) -> List[kbMatch] Returns Dict : ipr_conn.upload_report return dictionary","title":"ipr/main"},{"location":"reference/ipr/main/#iprmain","text":"","title":"ipr/main"},{"location":"reference/ipr/main/#cache_gene_minimum","text":"CACHE_GENE_MINIMUM = 5000","title":"CACHE_GENE_MINIMUM"},{"location":"reference/ipr/main/#clean_unsupported_content","text":"Remove unsupported content. This content is either added to facilitate creation or to support upcoming and soon to be supported content that we would like to implement but is not yet supported by the upload def clean_unsupported_content(upload_content: Dict) -> Dict: Args upload_content ( Dict ) Returns Dict","title":"clean_unsupported_content()"},{"location":"reference/ipr/main/#create_report","text":"Run the matching and create the report JSON for upload to IPR def create_report( username: str, password: str, content: Dict, ipr_url: str = DEFAULT_URL, log_level: str = 'info', output_json_path: str = None, always_write_output_json: bool = False, ipr_upload: bool = True, interactive: bool = False, graphkb_url: str = '', generate_therapeutics: bool = False, generate_comments: bool = True, match_germline: bool = False, custom_kb_match_filter=None, ) -> Dict: Args username ( str ): the username for connecting to GraphKB and IPR password ( str ): the password for connecting to GraphKB and IPR content ( Dict ): report content ipr_url ( str ): base URL to use in connecting to IPR log_level ( str ): the logging level output_json_path ( str ): path to a JSON file to output the report upload body. always_write_output_json ( bool ): with successful IPR upload ipr_upload ( bool ): upload report to ipr interactive ( bool ): progressbars for interactive users graphkb_url ( str ) generate_therapeutics ( bool ): create therapeutic options for upload with the report generate_comments ( bool ): create the analyst comments section for upload with the report match_germline ( bool ): match only germline statements to germline events and non-germline statements to non-germline events. custom_kb_match_filter: function(List[kbMatch]) -> List[kbMatch] Returns Dict : ipr_conn.upload_report return dictionary","title":"create_report()"},{"location":"reference/ipr/summary/","text":"ipr/summary OTHER_DISEASES OTHER_DISEASES = 'other disease types' ENTREZ_GENE_URL ENTREZ_GENE_URL = 'https://www.ncbi.nlm.nih.gov/gene' GRAPHKB_GUI GRAPHKB_GUI = 'https://graphkb.bcgsc.ca' filter_by_record_class() Given a list of records, return the subset matching a class or list of classes def filter_by_record_class( record_list: List[Dict], *record_classes, exclude: bool = False ) -> List[Dict]: Args record_list ( List[Dict] ) Returns List[Dict] create_graphkb_link() Create a link for a set of statements to the GraphKB client def create_graphkb_link( record_ids: List[str], record_class: str = 'Statement', ) -> str: Args record_ids ( List[str] ) record_class ( str ) Returns str substitute_sentence_template() Create the filled-in sentence template for a given template and list of substitutions which may be the result of the aggregation of 1 or more statements def substitute_sentence_template( template: str, conditions: List[Record], subjects: List[Record], relevance: Record, evidence: List[Record], statement_rids: List[str] = [], disease_matches: Set[str] = set(), ) -> str: Args template ( str ) conditions ( List[Record] ) subjects ( List[Record] ) relevance ( Record ) evidence ( List[Record] ) statement_rids ( List[str] ) disease_matches ( Set[str] ) Returns str aggregate_statements() Group Statements that only differ in disease conditions and evidence def aggregate_statements( graphkb_conn: GraphKBConnection, template: str, statements: List[Statement], disease_matches: Set[str], ) -> Dict[str, str]: Args graphkb_conn ( GraphKBConnection ) template ( str ) statements ( List[Statement] ) disease_matches ( Set[str] ) Returns Dict[str, str] create_section_html() Generate HTML for a gene section of the comments def create_section_html( graphkb_conn: GraphKBConnection, gene_name: str, sentences_by_statement_id: Dict[str, str], statements: Dict[str, Statement], exp_variants: List[IprVariant], ) -> str: Args graphkb_conn ( GraphKBConnection ) gene_name ( str ) sentences_by_statement_id ( Dict[str, str] ) statements ( Dict[str, Statement] ) exp_variants (List[ IprVariant ]) Returns str section_statements_by_genes() Determine the statements associated with each gene name def section_statements_by_genes( graphkb_conn: GraphKBConnection, statements: Sequence[Statement] ) -> Dict[str, Set[str]]: Args graphkb_conn ( GraphKBConnection ) statements ( Sequence[Statement] ) Returns Dict[str, Set[str]] summarize() Given a list of GraphKB matches generate a text summary to add to the report def summarize( graphkb_conn: GraphKBConnection, matches: Sequence[KbMatch], disease_name: str, variants: List[IprVariant], ) -> str: Args graphkb_conn ( GraphKBConnection ) matches (Sequence[ KbMatch ]) disease_name ( str ) variants (List[ IprVariant ]) Returns str","title":"ipr/summary"},{"location":"reference/ipr/summary/#iprsummary","text":"","title":"ipr/summary"},{"location":"reference/ipr/summary/#other_diseases","text":"OTHER_DISEASES = 'other disease types'","title":"OTHER_DISEASES"},{"location":"reference/ipr/summary/#entrez_gene_url","text":"ENTREZ_GENE_URL = 'https://www.ncbi.nlm.nih.gov/gene'","title":"ENTREZ_GENE_URL"},{"location":"reference/ipr/summary/#graphkb_gui","text":"GRAPHKB_GUI = 'https://graphkb.bcgsc.ca'","title":"GRAPHKB_GUI"},{"location":"reference/ipr/summary/#filter_by_record_class","text":"Given a list of records, return the subset matching a class or list of classes def filter_by_record_class( record_list: List[Dict], *record_classes, exclude: bool = False ) -> List[Dict]: Args record_list ( List[Dict] ) Returns List[Dict]","title":"filter_by_record_class()"},{"location":"reference/ipr/summary/#create_graphkb_link","text":"Create a link for a set of statements to the GraphKB client def create_graphkb_link( record_ids: List[str], record_class: str = 'Statement', ) -> str: Args record_ids ( List[str] ) record_class ( str ) Returns str","title":"create_graphkb_link()"},{"location":"reference/ipr/summary/#substitute_sentence_template","text":"Create the filled-in sentence template for a given template and list of substitutions which may be the result of the aggregation of 1 or more statements def substitute_sentence_template( template: str, conditions: List[Record], subjects: List[Record], relevance: Record, evidence: List[Record], statement_rids: List[str] = [], disease_matches: Set[str] = set(), ) -> str: Args template ( str ) conditions ( List[Record] ) subjects ( List[Record] ) relevance ( Record ) evidence ( List[Record] ) statement_rids ( List[str] ) disease_matches ( Set[str] ) Returns str","title":"substitute_sentence_template()"},{"location":"reference/ipr/summary/#aggregate_statements","text":"Group Statements that only differ in disease conditions and evidence def aggregate_statements( graphkb_conn: GraphKBConnection, template: str, statements: List[Statement], disease_matches: Set[str], ) -> Dict[str, str]: Args graphkb_conn ( GraphKBConnection ) template ( str ) statements ( List[Statement] ) disease_matches ( Set[str] ) Returns Dict[str, str]","title":"aggregate_statements()"},{"location":"reference/ipr/summary/#create_section_html","text":"Generate HTML for a gene section of the comments def create_section_html( graphkb_conn: GraphKBConnection, gene_name: str, sentences_by_statement_id: Dict[str, str], statements: Dict[str, Statement], exp_variants: List[IprVariant], ) -> str: Args graphkb_conn ( GraphKBConnection ) gene_name ( str ) sentences_by_statement_id ( Dict[str, str] ) statements ( Dict[str, Statement] ) exp_variants (List[ IprVariant ]) Returns str","title":"create_section_html()"},{"location":"reference/ipr/summary/#section_statements_by_genes","text":"Determine the statements associated with each gene name def section_statements_by_genes( graphkb_conn: GraphKBConnection, statements: Sequence[Statement] ) -> Dict[str, Set[str]]: Args graphkb_conn ( GraphKBConnection ) statements ( Sequence[Statement] ) Returns Dict[str, Set[str]]","title":"section_statements_by_genes()"},{"location":"reference/ipr/summary/#summarize","text":"Given a list of GraphKB matches generate a text summary to add to the report def summarize( graphkb_conn: GraphKBConnection, matches: Sequence[KbMatch], disease_name: str, variants: List[IprVariant], ) -> str: Args graphkb_conn ( GraphKBConnection ) matches (Sequence[ KbMatch ]) disease_name ( str ) variants (List[ IprVariant ]) Returns str","title":"summarize()"},{"location":"reference/ipr/therapeutic_options/","text":"ipr/therapeutic_options upload variant and report information to IPR create_therapeutic_options() Generate therapeutic options summary from the list of kb-matches def create_therapeutic_options( graphkb_conn: GraphKBConnection, kb_matches: List[KbMatch], variants: List[IprVariant] ) -> List[Dict]: Args graphkb_conn ( GraphKBConnection ) kb_matches (List[ KbMatch ]) variants (List[ IprVariant ]) Returns List[Dict]","title":"ipr/therapeutic_options"},{"location":"reference/ipr/therapeutic_options/#iprtherapeutic_options","text":"upload variant and report information to IPR","title":"ipr/therapeutic_options"},{"location":"reference/ipr/therapeutic_options/#create_therapeutic_options","text":"Generate therapeutic options summary from the list of kb-matches def create_therapeutic_options( graphkb_conn: GraphKBConnection, kb_matches: List[KbMatch], variants: List[IprVariant] ) -> List[Dict]: Args graphkb_conn ( GraphKBConnection ) kb_matches (List[ KbMatch ]) variants (List[ IprVariant ]) Returns List[Dict]","title":"create_therapeutic_options()"},{"location":"reference/ipr/types/","text":"ipr/types IprVariant IprVariant = Union[IprGeneVariant, IprStructuralVariant] class KbMatch inherits TypedDict Attributes variant ( str ) variantType ( str ) approvedTherapy ( bool ) category ( str ) context ( str ) kbContextId ( str ) disease ( str ) evidenceLevel ( str ) kbStatementId ( str ) kbVariant ( str ) kbVariantId ( str ) matchedCancer ( bool ) reference ( str ) relevance ( str ) kbRelevanceId ( str ) externalSource ( str ) externalStatementId ( str ) reviewStatus ( str ) class IprGeneVariant inherits TypedDict Attributes gene ( str ) key ( str ) variantType ( str ) variant ( str ) class IprGene inherits TypedDict Attributes name ( str ) cancerRelated ( Optional[bool] ) knownFusionPartner ( Optional[bool] ) knownSmallMutation ( Optional[bool] ) tumourSuppressor ( Optional[bool] ) oncogene ( Optional[bool] ) therapeuticAssociated ( Optional[bool] ) class IprStructuralVariant inherits TypedDict Attributes key ( str ) variantType ( str ) variant ( str ) gene1 ( str ) gene2 ( str ) exon1 ( int ) exon2 ( int ) class ImageDefinition inherits TypedDict Attributes key ( str ) path ( str )","title":"ipr/types"},{"location":"reference/ipr/types/#iprtypes","text":"","title":"ipr/types"},{"location":"reference/ipr/types/#iprvariant","text":"IprVariant = Union[IprGeneVariant, IprStructuralVariant]","title":"IprVariant"},{"location":"reference/ipr/types/#class-kbmatch","text":"inherits TypedDict Attributes variant ( str ) variantType ( str ) approvedTherapy ( bool ) category ( str ) context ( str ) kbContextId ( str ) disease ( str ) evidenceLevel ( str ) kbStatementId ( str ) kbVariant ( str ) kbVariantId ( str ) matchedCancer ( bool ) reference ( str ) relevance ( str ) kbRelevanceId ( str ) externalSource ( str ) externalStatementId ( str ) reviewStatus ( str )","title":"class KbMatch"},{"location":"reference/ipr/types/#class-iprgenevariant","text":"inherits TypedDict Attributes gene ( str ) key ( str ) variantType ( str ) variant ( str )","title":"class IprGeneVariant"},{"location":"reference/ipr/types/#class-iprgene","text":"inherits TypedDict Attributes name ( str ) cancerRelated ( Optional[bool] ) knownFusionPartner ( Optional[bool] ) knownSmallMutation ( Optional[bool] ) tumourSuppressor ( Optional[bool] ) oncogene ( Optional[bool] ) therapeuticAssociated ( Optional[bool] )","title":"class IprGene"},{"location":"reference/ipr/types/#class-iprstructuralvariant","text":"inherits TypedDict Attributes key ( str ) variantType ( str ) variant ( str ) gene1 ( str ) gene2 ( str ) exon1 ( int ) exon2 ( int )","title":"class IprStructuralVariant"},{"location":"reference/ipr/types/#class-imagedefinition","text":"inherits TypedDict Attributes key ( str ) path ( str )","title":"class ImageDefinition"},{"location":"reference/ipr/util/","text":"ipr/util VERBOSE_ERROR_CODE VERBOSE_ERROR_CODE = (logging.INFO + logging.DEBUG) // 2 logger logger = logging.getLogger('ipr') LOG_LEVELS LOG_LEVELS = { 'info': logging.INFO, 'debug': logging.DEBUG, 'warn': logging.WARN, 'error': logging.ERROR, 'verbose': VERBOSE_ERROR_CODE, create_variant_name() Given an IPR variant row, create the variant representation to be used as the name of the variant def create_variant_name(variant: IprVariant) -> str: Args variant ( IprVariant ) Returns str create_variant_name_tuple() Given an IPR variant row, create the variant representation to be used as the name of the variant def create_variant_name_tuple(variant: IprVariant) -> Tuple[str, str]: Args variant ( IprVariant ) Returns Tuple[str, str] find_variant() Find a variant in a list of variants by its key and type def find_variant(all_variants: List[IprVariant], variant_type: str, variant_key: str) -> IprVariant: Args all_variants (List[ IprVariant ]) variant_type ( str ) variant_key ( str ) Returns IprVariant generate_ontology_preference_key() Generate a tuple key for comparing preferred ontology terms. def generate_ontology_preference_key(record: Dict, sources_sort: Dict[str, int] = {}) -> Tuple: Args record ( Dict ) sources_sort ( Dict[str, int] ) Returns Tuple get_preferred_drug_representation() Given a Drug record, follow its linked records to find the preferred representation by following alias, deprecating, and cross reference links def get_preferred_drug_representation(graphkb_conn: GraphKBConnection, drug_record_id: str) -> Dict: Args graphkb_conn ( GraphKBConnection ) drug_record_id ( str ) Returns Dict get_preferred_gene_name() Given some Feature record ID return the preferred gene name def get_preferred_gene_name(graphkb_conn: GraphKBConnection, record_id: str) -> str: Args graphkb_conn ( GraphKBConnection ) record_id ( str ) Returns str pandas_falsy() Check if a field is python falsy or pandas null def pandas_falsy(field: Any) -> bool: Args field ( Any ) Returns bool","title":"ipr/util"},{"location":"reference/ipr/util/#iprutil","text":"","title":"ipr/util"},{"location":"reference/ipr/util/#verbose_error_code","text":"VERBOSE_ERROR_CODE = (logging.INFO + logging.DEBUG) // 2","title":"VERBOSE_ERROR_CODE"},{"location":"reference/ipr/util/#logger","text":"logger = logging.getLogger('ipr')","title":"logger"},{"location":"reference/ipr/util/#log_levels","text":"LOG_LEVELS = { 'info': logging.INFO, 'debug': logging.DEBUG, 'warn': logging.WARN, 'error': logging.ERROR, 'verbose': VERBOSE_ERROR_CODE,","title":"LOG_LEVELS"},{"location":"reference/ipr/util/#create_variant_name","text":"Given an IPR variant row, create the variant representation to be used as the name of the variant def create_variant_name(variant: IprVariant) -> str: Args variant ( IprVariant ) Returns str","title":"create_variant_name()"},{"location":"reference/ipr/util/#create_variant_name_tuple","text":"Given an IPR variant row, create the variant representation to be used as the name of the variant def create_variant_name_tuple(variant: IprVariant) -> Tuple[str, str]: Args variant ( IprVariant ) Returns Tuple[str, str]","title":"create_variant_name_tuple()"},{"location":"reference/ipr/util/#find_variant","text":"Find a variant in a list of variants by its key and type def find_variant(all_variants: List[IprVariant], variant_type: str, variant_key: str) -> IprVariant: Args all_variants (List[ IprVariant ]) variant_type ( str ) variant_key ( str ) Returns IprVariant","title":"find_variant()"},{"location":"reference/ipr/util/#generate_ontology_preference_key","text":"Generate a tuple key for comparing preferred ontology terms. def generate_ontology_preference_key(record: Dict, sources_sort: Dict[str, int] = {}) -> Tuple: Args record ( Dict ) sources_sort ( Dict[str, int] ) Returns Tuple","title":"generate_ontology_preference_key()"},{"location":"reference/ipr/util/#get_preferred_drug_representation","text":"Given a Drug record, follow its linked records to find the preferred representation by following alias, deprecating, and cross reference links def get_preferred_drug_representation(graphkb_conn: GraphKBConnection, drug_record_id: str) -> Dict: Args graphkb_conn ( GraphKBConnection ) drug_record_id ( str ) Returns Dict","title":"get_preferred_drug_representation()"},{"location":"reference/ipr/util/#get_preferred_gene_name","text":"Given some Feature record ID return the preferred gene name def get_preferred_gene_name(graphkb_conn: GraphKBConnection, record_id: str) -> str: Args graphkb_conn ( GraphKBConnection ) record_id ( str ) Returns str","title":"get_preferred_gene_name()"},{"location":"reference/ipr/util/#pandas_falsy","text":"Check if a field is python falsy or pandas null def pandas_falsy(field: Any) -> bool: Args field ( Any ) Returns bool","title":"pandas_falsy()"}]}