{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"User Manual The IPR python package is a tool for generating an IPR report with GraphKB annotations. Lists of variants are parsed, annotated, and then uploaded as part of a report. See the user manual here Getting Started Install the package with pip pip install ipr This will require python 3.6 or greater. this can now be used as a command line tool ipr -h or as part of a script from argparse import Namespace from ipr.main import create_report create_report(...)","title":"User Manual"},{"location":"#user-manual","text":"The IPR python package is a tool for generating an IPR report with GraphKB annotations. Lists of variants are parsed, annotated, and then uploaded as part of a report. See the user manual here","title":"User Manual"},{"location":"#getting-started","text":"Install the package with pip pip install ipr This will require python 3.6 or greater. this can now be used as a command line tool ipr -h or as part of a script from argparse import Namespace from ipr.main import create_report create_report(...)","title":"Getting Started"},{"location":"variant_inputs/","text":"Variant Input Files The reference documentation for genomic_report.inputs contains the function signatures. This document is focused on users building the files. All variant files for the genomic report use a tab delimited format. The column names, types and example inputs are shown below. Expression Variant Data Required Columns Column Type Description gene string the gene name (or source identifier) kbCategory string the graphkb expression variant vocabulary term this variant belongs to expressionState string the variant used for display in the report Optional Columns Column Type Description rnaReads float rpkm float reads per kilobase of transcript, per million mapped reads tpm float transcript per million diseasePercentile float the percentile with respect to the disease expression comparator cohort diseasekIQR float the kIQR with respect to the disease expression comparator cohort diseaseZScore float the zscore with respect to the disease expression comparator cohort diseaseFoldChange float the fold change with respect to the median of the disease expression comparator cohort diseaseQC float primarySitePercentile float the percentile with respect to the normal primary site expression comparator cohort primarySitekIQR float the kIQR with respect to the normal primary site expression comparator cohort primarySiteZScore float the zscore with respect to the normal primary site expression comparator cohort primarySiteFoldChange float the fold change with respect to the median of the normal primary site expression comparator cohort primarySiteQC float biopsySitePercentile float the percentile with respect to the normal biopsy site expression comparator cohort biopsySitekIQR float the kIQR with respect to the normal biopsy site expression comparator cohort biopsySiteZScore float the zscore with respect to the normal biopsy site expression comparator cohort biopsySiteFoldChange float the fold change with respect to the median of the normal biopsy site expression comparator cohort biopsySiteQC float Small Mutation Data Small mutations are composed of indels and single nucleotide variants. Required Columns Column Type Example Description chromosome string X the chromosome startPostion integer 1234 the genomic start position of this variant endPosition integer 1234 the genomic end position of this variant refSeq string A the reference sequence altSeq string C the alternate/new sequence gene string KRAS the gene name proteinChange string p.G12D the HGVS protein notation transcript string ENST00001.2 the transcript name Optional Columns Column Type Example Description zygosity string het tumourRefCount integer 1 the number of reference reads in the tumour genome tumourAltCount integer 1 the number of alternate reads in the tumour genome supporting the mutation tumourDepth integer 1 the total number of reads at this position in the tumour genome rnaRefCount integer 1 the number of reference reads in the rna rnaAltCount integer 1 the number of alternate reads in the rna supporting the mutation rnaDepth integer 1 the total number of reads at this position in the rna normalRefCount integer 1 the number of reference reads in the normal genome normalAltCount integer 1 the number of alternate reads in the normal genome supporting the mutation normalDepth integer 1 the total number of reads at this position in the normal genome detectedIn string DNA/RNA the sample types this variant was detected in hgvsCds string ENST0001:c.1234+3A>G HGVS coding sequence notation for this variant hgvsGenomic string 1:g.1234A>G HGVS genomic notation for this variant hgvsProtein string KRAS:p.G12D HGVS protein notation for this variant ncbiBuild string GRCh37 the genome reference assembly build version Copy Variant Data Required Columns Column Type Example Description gene string KRAS the gene name kbCategory string the graphkb copy variant vocabulary term this variant belongs to Optional Columns Column Type Example Description copyChange integer -2 the ploidy corrected copy change lohState string HET the loss-of-heterozygosity category for this gene region chromosomeBand string X:p12.2 start integer the genomic start position of the copy segment this gene copy number was called from end integer the genomic end position of the copy segment this gene copy number was called from cna float 1.22 The copy number alteration (CNA) ratio log2Cna float Structural Variant (Fusion) Data Required Columns Column Type Example Description eventType string deletion the type of underlying structural variant breakpoint string 12:123456|14:1244662 description of the breakpoints involved in this structural variant gene1 string EWSR1 the 5' (n-terminal) gene name gene2 string FLI1 the 3' (c-terminal) gene name exon1 integer 1 the 5' (n-terminal) exon exon2 integer 2 the 3' (c-terminal) exon nTermTranscript string ENST0001.2 the 3' transcript name ctermTranscript string ENST004.5 the 5' transcript name Optional Columns Column Type Example Description detectedIn string DNA the sample type(s) this SV was detected in conventionalName string cytogenic descriptor svg string svg image file for this SV svgTitle string title for the svg omicSupport boolean flag to indicate this SV has support from both genome and transcriptome","title":"Variant Input Files"},{"location":"variant_inputs/#variant-input-files","text":"The reference documentation for genomic_report.inputs contains the function signatures. This document is focused on users building the files. All variant files for the genomic report use a tab delimited format. The column names, types and example inputs are shown below.","title":"Variant Input Files"},{"location":"variant_inputs/#expression-variant-data","text":"","title":"Expression Variant Data"},{"location":"variant_inputs/#required-columns","text":"Column Type Description gene string the gene name (or source identifier) kbCategory string the graphkb expression variant vocabulary term this variant belongs to expressionState string the variant used for display in the report","title":"Required Columns"},{"location":"variant_inputs/#optional-columns","text":"Column Type Description rnaReads float rpkm float reads per kilobase of transcript, per million mapped reads tpm float transcript per million diseasePercentile float the percentile with respect to the disease expression comparator cohort diseasekIQR float the kIQR with respect to the disease expression comparator cohort diseaseZScore float the zscore with respect to the disease expression comparator cohort diseaseFoldChange float the fold change with respect to the median of the disease expression comparator cohort diseaseQC float primarySitePercentile float the percentile with respect to the normal primary site expression comparator cohort primarySitekIQR float the kIQR with respect to the normal primary site expression comparator cohort primarySiteZScore float the zscore with respect to the normal primary site expression comparator cohort primarySiteFoldChange float the fold change with respect to the median of the normal primary site expression comparator cohort primarySiteQC float biopsySitePercentile float the percentile with respect to the normal biopsy site expression comparator cohort biopsySitekIQR float the kIQR with respect to the normal biopsy site expression comparator cohort biopsySiteZScore float the zscore with respect to the normal biopsy site expression comparator cohort biopsySiteFoldChange float the fold change with respect to the median of the normal biopsy site expression comparator cohort biopsySiteQC float","title":"Optional Columns"},{"location":"variant_inputs/#small-mutation-data","text":"Small mutations are composed of indels and single nucleotide variants.","title":"Small Mutation Data"},{"location":"variant_inputs/#required-columns_1","text":"Column Type Example Description chromosome string X the chromosome startPostion integer 1234 the genomic start position of this variant endPosition integer 1234 the genomic end position of this variant refSeq string A the reference sequence altSeq string C the alternate/new sequence gene string KRAS the gene name proteinChange string p.G12D the HGVS protein notation transcript string ENST00001.2 the transcript name","title":"Required Columns"},{"location":"variant_inputs/#optional-columns_1","text":"Column Type Example Description zygosity string het tumourRefCount integer 1 the number of reference reads in the tumour genome tumourAltCount integer 1 the number of alternate reads in the tumour genome supporting the mutation tumourDepth integer 1 the total number of reads at this position in the tumour genome rnaRefCount integer 1 the number of reference reads in the rna rnaAltCount integer 1 the number of alternate reads in the rna supporting the mutation rnaDepth integer 1 the total number of reads at this position in the rna normalRefCount integer 1 the number of reference reads in the normal genome normalAltCount integer 1 the number of alternate reads in the normal genome supporting the mutation normalDepth integer 1 the total number of reads at this position in the normal genome detectedIn string DNA/RNA the sample types this variant was detected in hgvsCds string ENST0001:c.1234+3A>G HGVS coding sequence notation for this variant hgvsGenomic string 1:g.1234A>G HGVS genomic notation for this variant hgvsProtein string KRAS:p.G12D HGVS protein notation for this variant ncbiBuild string GRCh37 the genome reference assembly build version","title":"Optional Columns"},{"location":"variant_inputs/#copy-variant-data","text":"","title":"Copy Variant Data"},{"location":"variant_inputs/#required-columns_2","text":"Column Type Example Description gene string KRAS the gene name kbCategory string the graphkb copy variant vocabulary term this variant belongs to","title":"Required Columns"},{"location":"variant_inputs/#optional-columns_2","text":"Column Type Example Description copyChange integer -2 the ploidy corrected copy change lohState string HET the loss-of-heterozygosity category for this gene region chromosomeBand string X:p12.2 start integer the genomic start position of the copy segment this gene copy number was called from end integer the genomic end position of the copy segment this gene copy number was called from cna float 1.22 The copy number alteration (CNA) ratio log2Cna float","title":"Optional Columns"},{"location":"variant_inputs/#structural-variant-fusion-data","text":"","title":"Structural Variant (Fusion) Data"},{"location":"variant_inputs/#required-columns_3","text":"Column Type Example Description eventType string deletion the type of underlying structural variant breakpoint string 12:123456|14:1244662 description of the breakpoints involved in this structural variant gene1 string EWSR1 the 5' (n-terminal) gene name gene2 string FLI1 the 3' (c-terminal) gene name exon1 integer 1 the 5' (n-terminal) exon exon2 integer 2 the 3' (c-terminal) exon nTermTranscript string ENST0001.2 the 3' transcript name ctermTranscript string ENST004.5 the 5' transcript name","title":"Required Columns"},{"location":"variant_inputs/#optional-columns_3","text":"Column Type Example Description detectedIn string DNA the sample type(s) this SV was detected in conventionalName string cytogenic descriptor svg string svg image file for this SV svgTitle string title for the svg omicSupport boolean flag to indicate this SV has support from both genome and transcriptome","title":"Optional Columns"},{"location":"optional_content/","text":"Additional Metadata Beyond the standard variant input files, the IPR python adapter also accepts other analyses results in the optional content JSON/dict. Some of these sections are detailed below with examples { \"alternateIdentifier\": \"string\", \"biopsyName\": \"string\", \"project\": \"string\", \"images\": [], \"patientInformation\": {}, \"mutationSignature\": [], \"tumourContent\": 45, \"ploidy\": \"diploid\", \"subtyping\": \"Luminal A\" }","title":"Additional Metadata"},{"location":"optional_content/#additional-metadata","text":"Beyond the standard variant input files, the IPR python adapter also accepts other analyses results in the optional content JSON/dict. Some of these sections are detailed below with examples { \"alternateIdentifier\": \"string\", \"biopsyName\": \"string\", \"project\": \"string\", \"images\": [], \"patientInformation\": {}, \"mutationSignature\": [], \"tumourContent\": 45, \"ploidy\": \"diploid\", \"subtyping\": \"Luminal A\" }","title":"Additional Metadata"},{"location":"optional_content/comparators/","text":"Comparators This is used to provide details on how outlier evaluations were performed by listing the cohorts that were used in the comparisons { \"comparators\": [ { \"analysisRole\": \"mutation burden (primary)\", \"name\": \"average\" }, { \"analysisRole\": \"expression (disease QC)\", \"name\": \"qc_tcga_comp_TARGET_RHD_percentile_median_(6)\", \"size\": 6 }, { \"analysisRole\": \"expression (primary site)\", \"name\": \"average\", \"size\": 1024 } ], } The field analysisRole can have the following values, each can only be used once per report cibersort (primary) cibersort (secondary) mixcr (primary) mixcr (secondary) HRD (primary) HRD (secondary) expression (disease) expression (disease QC) expression (primary site) expression (primary site QC) expression (biopsy site) expression (biopsy site QC) mutation burden (primary) mutation burden (secondary) mutation burden (tertiary) mutation burden (quaternary) mutation burden SV (primary) mutation burden SV (secondary) mutation burden SV (tertiary) mutation burden SV (quaternary) protein expression (primary) protein expression (secondary)","title":"Comparators"},{"location":"optional_content/comparators/#comparators","text":"This is used to provide details on how outlier evaluations were performed by listing the cohorts that were used in the comparisons { \"comparators\": [ { \"analysisRole\": \"mutation burden (primary)\", \"name\": \"average\" }, { \"analysisRole\": \"expression (disease QC)\", \"name\": \"qc_tcga_comp_TARGET_RHD_percentile_median_(6)\", \"size\": 6 }, { \"analysisRole\": \"expression (primary site)\", \"name\": \"average\", \"size\": 1024 } ], } The field analysisRole can have the following values, each can only be used once per report cibersort (primary) cibersort (secondary) mixcr (primary) mixcr (secondary) HRD (primary) HRD (secondary) expression (disease) expression (disease QC) expression (primary site) expression (primary site QC) expression (biopsy site) expression (biopsy site QC) mutation burden (primary) mutation burden (secondary) mutation burden (tertiary) mutation burden (quaternary) mutation burden SV (primary) mutation burden SV (secondary) mutation burden SV (tertiary) mutation burden SV (quaternary) protein expression (primary) protein expression (secondary)","title":"Comparators"},{"location":"optional_content/images/","text":"Images There are a number of images that can be uploaded to the report. Images require a path to the image and the key for the image. The image key is used to tell IPR how to place the image in the report. The following are examples with their expected format and image key. { \"images\": [ { \"key\": \"string\", \"path\": \"/path/to/image/file\", \"title\": \"\", \"caption\": \"\" } ] } Mutation Signature Plots key: mutSignature.barplot.sbs key: mutSignature.barplot.dbs key: mutSignature.barplot.indels Expression Correlation Subtyping Plots key: subtypePlot\\.\\S+ Copy Number Circos Plot key: cnvLoh.circos Mutation Burden Plots key: mutationBurden\\.(barplot|density|legend)_(sv|snv|indel)\\.(primary|secondary|tertiary|quaternary) Expression Density Plots key: expDensity\\.(\\S+) In the above the pattern is expected to be expDensity.<gene name> where the gene name matches the gene name(s) used for the expression variant definitions Expression Correlation Plot keys: expression.chart , expression.legend Structural Variant Circos Plots keys: circosSv.genome , circosSv.transcriptome Microbial Integration Circos Plots keys: microbial.circos.genome , microbial.circos.transcriptome Immune Related Plots Cibersort Cibersort Publication key: cibersort.cd8_positive_t-cell_scatter key: cibersort.combined_t-cell_scatter MiXCR MiXCR Publication key: mixcr.circos_trb_vj_gene_usage key: mixcr.dominance_vs_alpha_beta_t-cells_scatter","title":"Images"},{"location":"optional_content/images/#images","text":"There are a number of images that can be uploaded to the report. Images require a path to the image and the key for the image. The image key is used to tell IPR how to place the image in the report. The following are examples with their expected format and image key. { \"images\": [ { \"key\": \"string\", \"path\": \"/path/to/image/file\", \"title\": \"\", \"caption\": \"\" } ] }","title":"Images"},{"location":"optional_content/images/#mutation-signature-plots","text":"key: mutSignature.barplot.sbs key: mutSignature.barplot.dbs key: mutSignature.barplot.indels","title":"Mutation Signature Plots"},{"location":"optional_content/images/#expression-correlation-subtyping-plots","text":"key: subtypePlot\\.\\S+","title":"Expression Correlation Subtyping Plots"},{"location":"optional_content/images/#copy-number-circos-plot","text":"key: cnvLoh.circos","title":"Copy Number Circos Plot"},{"location":"optional_content/images/#mutation-burden-plots","text":"key: mutationBurden\\.(barplot|density|legend)_(sv|snv|indel)\\.(primary|secondary|tertiary|quaternary)","title":"Mutation Burden Plots"},{"location":"optional_content/images/#expression-density-plots","text":"key: expDensity\\.(\\S+) In the above the pattern is expected to be expDensity.<gene name> where the gene name matches the gene name(s) used for the expression variant definitions","title":"Expression Density Plots"},{"location":"optional_content/images/#expression-correlation-plot","text":"keys: expression.chart , expression.legend","title":"Expression Correlation Plot"},{"location":"optional_content/images/#structural-variant-circos-plots","text":"keys: circosSv.genome , circosSv.transcriptome","title":"Structural Variant Circos Plots"},{"location":"optional_content/images/#microbial-integration-circos-plots","text":"keys: microbial.circos.genome , microbial.circos.transcriptome","title":"Microbial Integration Circos Plots"},{"location":"optional_content/images/#immune-related-plots","text":"","title":"Immune Related Plots"},{"location":"optional_content/images/#cibersort","text":"Cibersort Publication key: cibersort.cd8_positive_t-cell_scatter key: cibersort.combined_t-cell_scatter","title":"Cibersort"},{"location":"optional_content/images/#mixcr","text":"MiXCR Publication key: mixcr.circos_trb_vj_gene_usage key: mixcr.dominance_vs_alpha_beta_t-cells_scatter","title":"MiXCR"},{"location":"optional_content/immune/","text":"Immune Related Content HLA Types (OptiType) OptiType publication { \"hlaTypes\": [ { \"pathology\": \"normal\", \"protocol\": \"DNA\", \"a1\": \"A*02:03\", \"a2\": \"A*11:01\", \"b1\": \"B*40:01\", \"b2\": \"B*38:02\", \"c1\": \"C*07:02\", \"c2\": \"C*07:02\" } ] } Immune Cell Types (Cibersort) Cibersort publication { \"immuneCellTypes\": { \"cellType\": \"combined T cell\", \"kbCategory\": \"moderate\", \"score\": 76, \"percentile\": 50 } } Example cell type values are B cells naive B cells memory Plasma cells T cells CD8 T cells CD4 naive T cells CD4 memory resting T cells CD4 memory activated T cells follicular helper T cells regulatory (Tregs) T cells gamma delta NK cells resting NK cells activated Monocytes Macrophages M0 Macrophages M1 Macrophages M2 Dendritic cells resting Dendritic cells activated Mast cells resting Mast cells activated Eosinophils Neutrophils T.cell.inflitration","title":"Immune Related Content"},{"location":"optional_content/immune/#immune-related-content","text":"","title":"Immune Related Content"},{"location":"optional_content/immune/#hla-types-optitype","text":"OptiType publication { \"hlaTypes\": [ { \"pathology\": \"normal\", \"protocol\": \"DNA\", \"a1\": \"A*02:03\", \"a2\": \"A*11:01\", \"b1\": \"B*40:01\", \"b2\": \"B*38:02\", \"c1\": \"C*07:02\", \"c2\": \"C*07:02\" } ] }","title":"HLA Types (OptiType)"},{"location":"optional_content/immune/#immune-cell-types-cibersort","text":"Cibersort publication { \"immuneCellTypes\": { \"cellType\": \"combined T cell\", \"kbCategory\": \"moderate\", \"score\": 76, \"percentile\": 50 } } Example cell type values are B cells naive B cells memory Plasma cells T cells CD8 T cells CD4 naive T cells CD4 memory resting T cells CD4 memory activated T cells follicular helper T cells regulatory (Tregs) T cells gamma delta NK cells resting NK cells activated Monocytes Macrophages M0 Macrophages M1 Macrophages M2 Dendritic cells resting Dendritic cells activated Mast cells resting Mast cells activated Eosinophils Neutrophils T.cell.inflitration","title":"Immune Cell Types (Cibersort)"},{"location":"optional_content/mutation_burden/","text":"Mutation Burden Measure of the relative counts of various types of mutations compared to those from a given cohort of samples. The \"role\" determines with comparator these values are calculated in reference to { \"mutationBurden\": [ { \"snv\": 4, \"snvTruncating\": 0, \"indels\": 0, \"indelsFrameshift\": 0, \"sv\": 92, \"svExpressed\": 40, \"snvPercentile\": 4, \"indelPercentile\": 10, \"svPercentile\": 60, \"role\": \"primary\" } ], }","title":"Mutation Burden"},{"location":"optional_content/mutation_burden/#mutation-burden","text":"Measure of the relative counts of various types of mutations compared to those from a given cohort of samples. The \"role\" determines with comparator these values are calculated in reference to { \"mutationBurden\": [ { \"snv\": 4, \"snvTruncating\": 0, \"indels\": 0, \"indelsFrameshift\": 0, \"sv\": 92, \"svExpressed\": 40, \"snvPercentile\": 4, \"indelPercentile\": 10, \"svPercentile\": 60, \"role\": \"primary\" } ], }","title":"Mutation Burden"},{"location":"optional_content/pairwise_expression/","text":"Pairwise RNA Expression Correlation Provide a list of the most similar other samples with respect to the RNA expression profile. { \"pairwiseExpressionCorrelation\": [ { \"patientId\": \"UPLOADPAT02\", \"library\": \"LIB0002\", \"correlation\": 0.99, \"tumourType\": \"pancreatic cancer\", \"tissueType\": \"liver\", \"tumourContent\": 15 } ] } All values expect the correlation are attributes of the sample being compared to and not the sample the report is being generated for","title":"Pairwise RNA Expression Correlation"},{"location":"optional_content/pairwise_expression/#pairwise-rna-expression-correlation","text":"Provide a list of the most similar other samples with respect to the RNA expression profile. { \"pairwiseExpressionCorrelation\": [ { \"patientId\": \"UPLOADPAT02\", \"library\": \"LIB0002\", \"correlation\": 0.99, \"tumourType\": \"pancreatic cancer\", \"tissueType\": \"liver\", \"tumourContent\": 15 } ] } All values expect the correlation are attributes of the sample being compared to and not the sample the report is being generated for","title":"Pairwise RNA Expression Correlation"},{"location":"optional_content/patient/","text":"Patient Metadata { \"patientInformation\": { \"age\": \"\", \"biopsySite\": \"Description of biopsy site\", \"caseType\": \"Adult\", \"constitutionalProtocol\": \"WGS\", \"constitutionalSample\": \"Blood-Peripheral\", \"diagnosis\": \"patient disease diagnosis\", \"gender\": \"Male\", \"physician\": \"Dr. Who\", \"tumourProtocol\": \"WGS/RNA-Seq\", \"tumourSample\": \"Metastatic\" } }","title":"Patient Metadata"},{"location":"optional_content/patient/#patient-metadata","text":"{ \"patientInformation\": { \"age\": \"\", \"biopsySite\": \"Description of biopsy site\", \"caseType\": \"Adult\", \"constitutionalProtocol\": \"WGS\", \"constitutionalSample\": \"Blood-Peripheral\", \"diagnosis\": \"patient disease diagnosis\", \"gender\": \"Male\", \"physician\": \"Dr. Who\", \"tumourProtocol\": \"WGS/RNA-Seq\", \"tumourSample\": \"Metastatic\" } }","title":"Patient Metadata"},{"location":"optional_content/signature/","text":"Mutation Signatures These are the scores of individual mutation signatures. These can include cosmic and/or custom signatures. The nnls field is the non-negative least squares contribution of the given signature { \"mutationSignature\": [ { \"signature\": \"SBS1\", \"nnls\": 0.344, \"associations\": \"Tobacco chewing\", \"features\": \"D,T\", \"numCancerTypes\": 1, \"cancerTypes\": \"stomach cancer\", \"selected\": false, \"kbCategory\": \"strong signature\" } ] } The selected field indicates if this signature should be shown on the front page of the report or not","title":"Mutation Signatures"},{"location":"optional_content/signature/#mutation-signatures","text":"These are the scores of individual mutation signatures. These can include cosmic and/or custom signatures. The nnls field is the non-negative least squares contribution of the given signature { \"mutationSignature\": [ { \"signature\": \"SBS1\", \"nnls\": 0.344, \"associations\": \"Tobacco chewing\", \"features\": \"D,T\", \"numCancerTypes\": 1, \"cancerTypes\": \"stomach cancer\", \"selected\": false, \"kbCategory\": \"strong signature\" } ] } The selected field indicates if this signature should be shown on the front page of the report or not","title":"Mutation Signatures"},{"location":"reference/ipr/annotate/","text":"ipr.annotate handles annotating variants with annotation information from graphkb get_gene_information() Create the Gene Info object for upload to IPR with the other report information def get_gene_information( graphkb_conn: GraphKBConnection, gene_names: Iterable[str] ) -> List[IprGene]: Args graphkb_conn ( GraphKBConnection ): [description] gene_names ( Iterable[str] ): [description] Returns List[ IprGene ] get_statements_from_variants() Given a list of variant records from GraphKB, return all the related statements def get_statements_from_variants( graphkb_conn: GraphKBConnection, variants: List[Record] ) -> List[Statement]: Args graphkb_conn ( GraphKBConnection ): the graphkb api connection object variants ( List[Record] ): list of variant records Returns List[Statement] : list of Statement records from graphkb get_ipr_statements_from_variants() Matches to GraphKB statements from the list of input variants. From these results matches again with the inferred variants. Then returns the results formatted for upload to IPR def get_ipr_statements_from_variants( graphkb_conn: GraphKBConnection, matches: List[Record], disease_name: str ) -> List[KbMatch]: Args graphkb_conn ( GraphKBConnection ) matches ( List[Record] ) disease_name ( str ) Returns List[ KbMatch ] annotate_category_variants() Annotate variant calls with information from GraphKB and return these annotations in the IPR alterations format def annotate_category_variants( graphkb_conn: GraphKBConnection, variants: List[IprGeneVariant], disease_name: str, copy_variant: bool = True, show_progress: bool = False, ) -> List[KbMatch]: Args graphkb_conn ( GraphKBConnection ): the graphkb api connection object variants (List[ IprGeneVariant ]): list of variants disease_name ( str ) copy_variant ( bool ) show_progress ( bool ) Returns List[ KbMatch ]: list of kbMatches records for IPR annotate_positional_variants() Annotate variant calls with information from GraphKB and return these annotations in the IPR alterations format def annotate_positional_variants( graphkb_conn: GraphKBConnection, variants: List[IprVariant], disease_name: str, show_progress: bool = False, ) -> List[KbMatch]: Args graphkb_conn ( GraphKBConnection ): the graphkb api connection object variants (List[ IprVariant ]): list of variants. Defaults to []. disease_name ( str ) show_progress ( bool ) Returns List[ KbMatch ]: list of kbMatches records for IPR","title":"ipr.annotate"},{"location":"reference/ipr/annotate/#iprannotate","text":"handles annotating variants with annotation information from graphkb","title":"ipr.annotate"},{"location":"reference/ipr/annotate/#get_gene_information","text":"Create the Gene Info object for upload to IPR with the other report information def get_gene_information( graphkb_conn: GraphKBConnection, gene_names: Iterable[str] ) -> List[IprGene]: Args graphkb_conn ( GraphKBConnection ): [description] gene_names ( Iterable[str] ): [description] Returns List[ IprGene ]","title":"get_gene_information()"},{"location":"reference/ipr/annotate/#get_statements_from_variants","text":"Given a list of variant records from GraphKB, return all the related statements def get_statements_from_variants( graphkb_conn: GraphKBConnection, variants: List[Record] ) -> List[Statement]: Args graphkb_conn ( GraphKBConnection ): the graphkb api connection object variants ( List[Record] ): list of variant records Returns List[Statement] : list of Statement records from graphkb","title":"get_statements_from_variants()"},{"location":"reference/ipr/annotate/#get_ipr_statements_from_variants","text":"Matches to GraphKB statements from the list of input variants. From these results matches again with the inferred variants. Then returns the results formatted for upload to IPR def get_ipr_statements_from_variants( graphkb_conn: GraphKBConnection, matches: List[Record], disease_name: str ) -> List[KbMatch]: Args graphkb_conn ( GraphKBConnection ) matches ( List[Record] ) disease_name ( str ) Returns List[ KbMatch ]","title":"get_ipr_statements_from_variants()"},{"location":"reference/ipr/annotate/#annotate_category_variants","text":"Annotate variant calls with information from GraphKB and return these annotations in the IPR alterations format def annotate_category_variants( graphkb_conn: GraphKBConnection, variants: List[IprGeneVariant], disease_name: str, copy_variant: bool = True, show_progress: bool = False, ) -> List[KbMatch]: Args graphkb_conn ( GraphKBConnection ): the graphkb api connection object variants (List[ IprGeneVariant ]): list of variants disease_name ( str ) copy_variant ( bool ) show_progress ( bool ) Returns List[ KbMatch ]: list of kbMatches records for IPR","title":"annotate_category_variants()"},{"location":"reference/ipr/annotate/#annotate_positional_variants","text":"Annotate variant calls with information from GraphKB and return these annotations in the IPR alterations format def annotate_positional_variants( graphkb_conn: GraphKBConnection, variants: List[IprVariant], disease_name: str, show_progress: bool = False, ) -> List[KbMatch]: Args graphkb_conn ( GraphKBConnection ): the graphkb api connection object variants (List[ IprVariant ]): list of variants. Defaults to []. disease_name ( str ) show_progress ( bool ) Returns List[ KbMatch ]: list of kbMatches records for IPR","title":"annotate_positional_variants()"},{"location":"reference/ipr/connection/","text":"ipr.connection IMAGE_MAX IMAGE_MAX = 20 # cannot upload more than 20 images at a time class IprConnection IprConnection.request() Request wrapper to handle adding common headers and logging def request(self, endpoint: str, method: str = 'GET', **kwargs) -> Dict: Args endpoint ( str ): api endpoint, excluding the base uri method ( str ): the http method. Defaults to 'GET'. Returns Dict : the json response as a python dict IprConnection.post() Convenience method for making post requests def post(self, uri: str, data: Dict = {}, **kwargs) -> Dict: Args uri ( str ) data ( Dict ) Returns Dict IprConnection.set_analyst_comments() Update report comments to an existing report def set_analyst_comments(self, report_id: str, data: Dict) -> Dict: Args report_id ( str ) data ( Dict ) Returns Dict !!! todo Add to main upload. Pending: https://www.bcgsc.ca/jira/browse/DEVSU-1177 IprConnection.post_images() Post images to the report def post_images(self, report_id: str, files: Dict[str, str], data: Dict[str, str] = {}) -> None: Args report_id ( str ) files ( Dict[str, str] ) data ( Dict[str, str] )","title":"ipr.connection"},{"location":"reference/ipr/connection/#iprconnection","text":"","title":"ipr.connection"},{"location":"reference/ipr/connection/#image_max","text":"IMAGE_MAX = 20 # cannot upload more than 20 images at a time","title":"IMAGE_MAX"},{"location":"reference/ipr/connection/#class-iprconnection","text":"","title":"class IprConnection"},{"location":"reference/ipr/connection/#iprconnectionrequest","text":"Request wrapper to handle adding common headers and logging def request(self, endpoint: str, method: str = 'GET', **kwargs) -> Dict: Args endpoint ( str ): api endpoint, excluding the base uri method ( str ): the http method. Defaults to 'GET'. Returns Dict : the json response as a python dict","title":"IprConnection.request()"},{"location":"reference/ipr/connection/#iprconnectionpost","text":"Convenience method for making post requests def post(self, uri: str, data: Dict = {}, **kwargs) -> Dict: Args uri ( str ) data ( Dict ) Returns Dict","title":"IprConnection.post()"},{"location":"reference/ipr/connection/#iprconnectionset_analyst_comments","text":"Update report comments to an existing report def set_analyst_comments(self, report_id: str, data: Dict) -> Dict: Args report_id ( str ) data ( Dict ) Returns Dict !!! todo Add to main upload. Pending: https://www.bcgsc.ca/jira/browse/DEVSU-1177","title":"IprConnection.set_analyst_comments()"},{"location":"reference/ipr/connection/#iprconnectionpost_images","text":"Post images to the report def post_images(self, report_id: str, files: Dict[str, str], data: Dict[str, str] = {}) -> None: Args report_id ( str ) files ( Dict[str, str] ) data ( Dict[str, str] )","title":"IprConnection.post_images()"},{"location":"reference/ipr/inputs/","text":"ipr.inputs Read/Validate the variant input files NULLABLE_FLOAT_REGEX NULLABLE_FLOAT_REGEX = r'^-?((inf)|(\\d+(\\.\\d+)?)|)$' COPY_REQ COPY_REQ = ['gene', 'kbCategory'] COPY_KEY COPY_KEY = ['gene'] COPY_OPTIONAL COPY_OPTIONAL = [ 'cnvState', 'copyChange', 'lohState', # Loss of Heterzygosity state - informative detail to analyst 'chromosomeBand', 'start', 'end', 'size', 'log2Cna', 'cna', ] SMALL_MUT_REQ SMALL_MUT_REQ = ['gene', 'proteinChange'] SMALL_MUT_KEY SMALL_MUT_KEY = SMALL_MUT_REQ + [ 'altSeq', 'chromosome', 'endPosition', 'refSeq', 'startPosition', 'transcript', SMALL_MUT_OPTIONAL SMALL_MUT_OPTIONAL = [ 'altSeq', 'chromosome', 'endPosition', 'hgvsCds', 'hgvsGenomic', 'hgvsProtein', 'ncbiBuild', 'normalAltCount', 'normalDepth', 'normalRefCount', 'refSeq', 'rnaAltCount', 'rnaDepth', 'rnaRefCount', 'startPosition', 'transcript', 'tumourAltCount', 'tumourDepth', 'tumourRefCount', 'zygosity', ] EXP_REQ EXP_REQ = ['gene', 'kbCategory'] EXP_KEY EXP_KEY = ['gene'] EXP_OPTIONAL EXP_OPTIONAL = [ 'biopsySiteFoldChange', 'biopsySitePercentile', 'biopsySiteQC', 'biopsySiteZScore', 'biopsySitekIQR', 'diseaseFoldChange', 'diseasekIQR', 'diseasePercentile', 'diseaseQC', 'diseaseZScore', 'expressionState', 'histogramImage', 'primarySiteFoldChange', 'primarySitekIQR', 'primarySitePercentile', 'primarySiteQC', 'primarySiteZScore', 'rnaReads', 'rpkm', 'tpm', ] SV_REQ SV_REQ = [ 'eventType', 'breakpoint', 'gene1', # prev: nterm_hugo 'gene2', # prev: cterm_hugo 'exon1', # n-terminal 'exon2', # c-terminal ] SV_KEY SV_KEY = SV_REQ[:] SV_OPTIONAL SV_OPTIONAL = [ 'ctermTranscript', 'ntermTranscript', 'ctermGene', # combined hugo ensembl form 'ntermGene', # combined hugo ensembl form 'detectedIn', 'conventionalName', 'svg', 'svgTitle', 'name', 'frame', 'omicSupport', 'highQuality', ] validate_variant_rows() check that the required columns are present check that a unique key can be formed for each row drop any non-defined columns def validate_variant_rows( rows: Iterable[Dict], required: List[str], optional: List[str], row_to_key: Callable ) -> List[IprVariant]: Args rows ( Iterable[Dict] ): the input files rows required ( List[str] ) optional ( List[str] ): list of optional column names row_to_key ( Callable ): function to generate a key for a given row Returns List[ IprVariant ]: the rows from the tab file as dictionaries Raises ValueError : row keys are not unique ValueError : A required column is missing read_tabbed_file() Load a tab delimited file as dictionary rows def read_tabbed_file(filename: str) -> List[Dict]: Args filename ( str ) Returns List[Dict] validate_row_patterns() Validate rows against a regex for some set of columns def validate_row_patterns( rows: List[IprVariant], patterns: Dict, row_key_columns: List[str] ) -> None: Args rows (List[ IprVariant ]): input rows read from a delimited file patterns ( Dict ): mapping of column names to regex patterns the column are expected to match row_key_columns ( List[str] ) Raises ValueError : A row does not match the expected pattern for a given column preprocess_copy_variants() Validate the input rows contain the minimum required fields and generate any default values where possible def preprocess_copy_variants(rows: Iterable[Dict]) -> List[IprVariant]: Args rows ( Iterable[Dict] ) Returns List[ IprVariant ] preprocess_small_mutations() Validate the input rows contain the minimum required fields and generate any default values where possible def preprocess_small_mutations(rows: Iterable[Dict]) -> List[IprGeneVariant]: Args rows ( Iterable[Dict] ) Returns List[ IprGeneVariant ] preprocess_expression_variants() Validate the input rows contain the minimum required fields and generate any default values where possible def preprocess_expression_variants(rows: Iterable[Dict]) -> List[IprGeneVariant]: Args rows ( Iterable[Dict] ) Returns List[ IprGeneVariant ] create_graphkb_sv_notation() Generate GKB style structural variant notation from a structural variant input row def create_graphkb_sv_notation(row: IprStructuralVariant) -> str: Args row ( IprStructuralVariant ) Returns str preprocess_structural_variants() Validate the input rows contain the minimum required fields and generate any default values where possible def preprocess_structural_variants(rows: Iterable[Dict]) -> List[IprVariant]: Args rows ( Iterable[Dict] ) Returns List[ IprVariant ] check_variant_links() Check matching information for any genes with variants. Warn about genes with only one experimental measure. def check_variant_links( small_mutations: List[IprGeneVariant], expression_variants: List[IprGeneVariant], copy_variants: List[IprGeneVariant], structural_variants: List[IprStructuralVariant], ) -> Set[str]: Args small_mutations (List[ IprGeneVariant ]): list of small mutations expression_variants (List[ IprGeneVariant ]): list of expression variants copy_variants (List[ IprGeneVariant ]): list of copy variants structural_variants (List[ IprStructuralVariant ]): list of structural variants Returns Set[str] : set of gene names with variants (used for filtering before upload to IPR) check_comparators() Given the optional content dictionary, check that based on the analyses present the correct/sufficient comparators have also been specified def check_comparators(content: Dict, expresssionVariants: Iterable[Dict] = []) -> None: Args content ( Dict ) expresssionVariants ( Iterable[Dict] )","title":"ipr.inputs"},{"location":"reference/ipr/inputs/#iprinputs","text":"Read/Validate the variant input files","title":"ipr.inputs"},{"location":"reference/ipr/inputs/#nullable_float_regex","text":"NULLABLE_FLOAT_REGEX = r'^-?((inf)|(\\d+(\\.\\d+)?)|)$'","title":"NULLABLE_FLOAT_REGEX"},{"location":"reference/ipr/inputs/#copy_req","text":"COPY_REQ = ['gene', 'kbCategory']","title":"COPY_REQ"},{"location":"reference/ipr/inputs/#copy_key","text":"COPY_KEY = ['gene']","title":"COPY_KEY"},{"location":"reference/ipr/inputs/#copy_optional","text":"COPY_OPTIONAL = [ 'cnvState', 'copyChange', 'lohState', # Loss of Heterzygosity state - informative detail to analyst 'chromosomeBand', 'start', 'end', 'size', 'log2Cna', 'cna', ]","title":"COPY_OPTIONAL"},{"location":"reference/ipr/inputs/#small_mut_req","text":"SMALL_MUT_REQ = ['gene', 'proteinChange']","title":"SMALL_MUT_REQ"},{"location":"reference/ipr/inputs/#small_mut_key","text":"SMALL_MUT_KEY = SMALL_MUT_REQ + [ 'altSeq', 'chromosome', 'endPosition', 'refSeq', 'startPosition', 'transcript',","title":"SMALL_MUT_KEY"},{"location":"reference/ipr/inputs/#small_mut_optional","text":"SMALL_MUT_OPTIONAL = [ 'altSeq', 'chromosome', 'endPosition', 'hgvsCds', 'hgvsGenomic', 'hgvsProtein', 'ncbiBuild', 'normalAltCount', 'normalDepth', 'normalRefCount', 'refSeq', 'rnaAltCount', 'rnaDepth', 'rnaRefCount', 'startPosition', 'transcript', 'tumourAltCount', 'tumourDepth', 'tumourRefCount', 'zygosity', ]","title":"SMALL_MUT_OPTIONAL"},{"location":"reference/ipr/inputs/#exp_req","text":"EXP_REQ = ['gene', 'kbCategory']","title":"EXP_REQ"},{"location":"reference/ipr/inputs/#exp_key","text":"EXP_KEY = ['gene']","title":"EXP_KEY"},{"location":"reference/ipr/inputs/#exp_optional","text":"EXP_OPTIONAL = [ 'biopsySiteFoldChange', 'biopsySitePercentile', 'biopsySiteQC', 'biopsySiteZScore', 'biopsySitekIQR', 'diseaseFoldChange', 'diseasekIQR', 'diseasePercentile', 'diseaseQC', 'diseaseZScore', 'expressionState', 'histogramImage', 'primarySiteFoldChange', 'primarySitekIQR', 'primarySitePercentile', 'primarySiteQC', 'primarySiteZScore', 'rnaReads', 'rpkm', 'tpm', ]","title":"EXP_OPTIONAL"},{"location":"reference/ipr/inputs/#sv_req","text":"SV_REQ = [ 'eventType', 'breakpoint', 'gene1', # prev: nterm_hugo 'gene2', # prev: cterm_hugo 'exon1', # n-terminal 'exon2', # c-terminal ]","title":"SV_REQ"},{"location":"reference/ipr/inputs/#sv_key","text":"SV_KEY = SV_REQ[:]","title":"SV_KEY"},{"location":"reference/ipr/inputs/#sv_optional","text":"SV_OPTIONAL = [ 'ctermTranscript', 'ntermTranscript', 'ctermGene', # combined hugo ensembl form 'ntermGene', # combined hugo ensembl form 'detectedIn', 'conventionalName', 'svg', 'svgTitle', 'name', 'frame', 'omicSupport', 'highQuality', ]","title":"SV_OPTIONAL"},{"location":"reference/ipr/inputs/#validate_variant_rows","text":"check that the required columns are present check that a unique key can be formed for each row drop any non-defined columns def validate_variant_rows( rows: Iterable[Dict], required: List[str], optional: List[str], row_to_key: Callable ) -> List[IprVariant]: Args rows ( Iterable[Dict] ): the input files rows required ( List[str] ) optional ( List[str] ): list of optional column names row_to_key ( Callable ): function to generate a key for a given row Returns List[ IprVariant ]: the rows from the tab file as dictionaries Raises ValueError : row keys are not unique ValueError : A required column is missing","title":"validate_variant_rows()"},{"location":"reference/ipr/inputs/#read_tabbed_file","text":"Load a tab delimited file as dictionary rows def read_tabbed_file(filename: str) -> List[Dict]: Args filename ( str ) Returns List[Dict]","title":"read_tabbed_file()"},{"location":"reference/ipr/inputs/#validate_row_patterns","text":"Validate rows against a regex for some set of columns def validate_row_patterns( rows: List[IprVariant], patterns: Dict, row_key_columns: List[str] ) -> None: Args rows (List[ IprVariant ]): input rows read from a delimited file patterns ( Dict ): mapping of column names to regex patterns the column are expected to match row_key_columns ( List[str] ) Raises ValueError : A row does not match the expected pattern for a given column","title":"validate_row_patterns()"},{"location":"reference/ipr/inputs/#preprocess_copy_variants","text":"Validate the input rows contain the minimum required fields and generate any default values where possible def preprocess_copy_variants(rows: Iterable[Dict]) -> List[IprVariant]: Args rows ( Iterable[Dict] ) Returns List[ IprVariant ]","title":"preprocess_copy_variants()"},{"location":"reference/ipr/inputs/#preprocess_small_mutations","text":"Validate the input rows contain the minimum required fields and generate any default values where possible def preprocess_small_mutations(rows: Iterable[Dict]) -> List[IprGeneVariant]: Args rows ( Iterable[Dict] ) Returns List[ IprGeneVariant ]","title":"preprocess_small_mutations()"},{"location":"reference/ipr/inputs/#preprocess_expression_variants","text":"Validate the input rows contain the minimum required fields and generate any default values where possible def preprocess_expression_variants(rows: Iterable[Dict]) -> List[IprGeneVariant]: Args rows ( Iterable[Dict] ) Returns List[ IprGeneVariant ]","title":"preprocess_expression_variants()"},{"location":"reference/ipr/inputs/#create_graphkb_sv_notation","text":"Generate GKB style structural variant notation from a structural variant input row def create_graphkb_sv_notation(row: IprStructuralVariant) -> str: Args row ( IprStructuralVariant ) Returns str","title":"create_graphkb_sv_notation()"},{"location":"reference/ipr/inputs/#preprocess_structural_variants","text":"Validate the input rows contain the minimum required fields and generate any default values where possible def preprocess_structural_variants(rows: Iterable[Dict]) -> List[IprVariant]: Args rows ( Iterable[Dict] ) Returns List[ IprVariant ]","title":"preprocess_structural_variants()"},{"location":"reference/ipr/inputs/#check_variant_links","text":"Check matching information for any genes with variants. Warn about genes with only one experimental measure. def check_variant_links( small_mutations: List[IprGeneVariant], expression_variants: List[IprGeneVariant], copy_variants: List[IprGeneVariant], structural_variants: List[IprStructuralVariant], ) -> Set[str]: Args small_mutations (List[ IprGeneVariant ]): list of small mutations expression_variants (List[ IprGeneVariant ]): list of expression variants copy_variants (List[ IprGeneVariant ]): list of copy variants structural_variants (List[ IprStructuralVariant ]): list of structural variants Returns Set[str] : set of gene names with variants (used for filtering before upload to IPR)","title":"check_variant_links()"},{"location":"reference/ipr/inputs/#check_comparators","text":"Given the optional content dictionary, check that based on the analyses present the correct/sufficient comparators have also been specified def check_comparators(content: Dict, expresssionVariants: Iterable[Dict] = []) -> None: Args content ( Dict ) expresssionVariants ( Iterable[Dict] )","title":"check_comparators()"},{"location":"reference/ipr/ipr/","text":"ipr.ipr Contains functions specific to formatting reports for IPR that are unlikely to be used by other reporting systems filter_structural_variants() Filter structural variants to remove non-high quality events unless they are matched/annotated or they involve a gene that is a known fusion partner def filter_structural_variants( structural_variants: List[IprStructuralVariant], kb_matches: List[KbMatch], gene_annotations: List[IprGene], ) -> List[IprStructuralVariant]: Args structural_variants (List[ IprStructuralVariant ]) kb_matches (List[ KbMatch ]) gene_annotations (List[ IprGene ]) Returns List[ IprStructuralVariant ] convert_statements_to_alterations() Given a set of statements matched from graphkb, convert these into their IPR equivalent representations def convert_statements_to_alterations( graphkb_conn: GraphKBConnection, statements: List[Statement], disease_name: str, variant_matches: Iterable[str], ) -> List[KbMatch]: Args graphkb_conn ( GraphKBConnection ): the graphkb connection object statements ( List[Statement] ): list of statement records from graphkb disease_name ( str ): name of the cancer type for the patient being reported on variant_matches ( Iterable[str] ): the list of RIDs the variant matched for these statements Returns List[ KbMatch ]: IPR graphkb row representations Notes: - only report disease matched prognostic markers https://www.bcgsc.ca/jira/browse/GERO-72 Raises ValueError : could not find the disease type in GraphKB select_expression_plots() Given the list of expression variants, determine which expression historgram plots should be included in the IPR upload. This filters them based on the graphkb annotations to avoid loading more images than are required def select_expression_plots( kb_matches: List[KbMatch], all_variants: List[IprVariant] ) -> List[Dict[str, ImageDefinition]]: Args kb_matches (List[ KbMatch ]): the IPR graphkb annoations for all variants all_variants (List[ IprVariant ]) Returns List[Dict[ str , ImageDefinition ]]: list of expression images to be loaded by IPR create_key_alterations() Creates the list of genomic key alterations which summarizes all the variants matched by the KB This list of matches is also used to create the variant counts def create_key_alterations( kb_matches: List[KbMatch], all_variants: List[IprVariant], ) -> Tuple[List[Dict], Dict]: Args kb_matches (List[ KbMatch ]) all_variants (List[ IprVariant ]) Returns Tuple[List[Dict], Dict]","title":"ipr.ipr"},{"location":"reference/ipr/ipr/#ipripr","text":"Contains functions specific to formatting reports for IPR that are unlikely to be used by other reporting systems","title":"ipr.ipr"},{"location":"reference/ipr/ipr/#filter_structural_variants","text":"Filter structural variants to remove non-high quality events unless they are matched/annotated or they involve a gene that is a known fusion partner def filter_structural_variants( structural_variants: List[IprStructuralVariant], kb_matches: List[KbMatch], gene_annotations: List[IprGene], ) -> List[IprStructuralVariant]: Args structural_variants (List[ IprStructuralVariant ]) kb_matches (List[ KbMatch ]) gene_annotations (List[ IprGene ]) Returns List[ IprStructuralVariant ]","title":"filter_structural_variants()"},{"location":"reference/ipr/ipr/#convert_statements_to_alterations","text":"Given a set of statements matched from graphkb, convert these into their IPR equivalent representations def convert_statements_to_alterations( graphkb_conn: GraphKBConnection, statements: List[Statement], disease_name: str, variant_matches: Iterable[str], ) -> List[KbMatch]: Args graphkb_conn ( GraphKBConnection ): the graphkb connection object statements ( List[Statement] ): list of statement records from graphkb disease_name ( str ): name of the cancer type for the patient being reported on variant_matches ( Iterable[str] ): the list of RIDs the variant matched for these statements Returns List[ KbMatch ]: IPR graphkb row representations Notes: - only report disease matched prognostic markers https://www.bcgsc.ca/jira/browse/GERO-72 Raises ValueError : could not find the disease type in GraphKB","title":"convert_statements_to_alterations()"},{"location":"reference/ipr/ipr/#select_expression_plots","text":"Given the list of expression variants, determine which expression historgram plots should be included in the IPR upload. This filters them based on the graphkb annotations to avoid loading more images than are required def select_expression_plots( kb_matches: List[KbMatch], all_variants: List[IprVariant] ) -> List[Dict[str, ImageDefinition]]: Args kb_matches (List[ KbMatch ]): the IPR graphkb annoations for all variants all_variants (List[ IprVariant ]) Returns List[Dict[ str , ImageDefinition ]]: list of expression images to be loaded by IPR","title":"select_expression_plots()"},{"location":"reference/ipr/ipr/#create_key_alterations","text":"Creates the list of genomic key alterations which summarizes all the variants matched by the KB This list of matches is also used to create the variant counts def create_key_alterations( kb_matches: List[KbMatch], all_variants: List[IprVariant], ) -> Tuple[List[Dict], Dict]: Args kb_matches (List[ KbMatch ]) all_variants (List[ IprVariant ]) Returns Tuple[List[Dict], Dict]","title":"create_key_alterations()"},{"location":"reference/ipr/main/","text":"ipr.main CACHE_GENE_MINIMUM CACHE_GENE_MINIMUM = 5000 clean_unsupported_content() Remove unsupported content. This content is either added to facilitate creation or to support upcoming and soon to be supported content that we would like to implement but is not yet supported by the upload def clean_unsupported_content(upload_content: Dict) -> Dict: Args upload_content ( Dict ) Returns Dict create_report() Run the matching and create the report JSON for upload to IPR def create_report( username: str, password: str, patient_id: str, kb_disease_match: str, project: str = 'TEST', ipr_url: str = DEFAULT_URL, log_level: str = 'info', expression_variant_rows: Iterable[Dict] = [], structural_variant_rows: Iterable[Dict] = [], copy_variant_rows: Iterable[Dict] = [], small_mutation_rows: Iterable[Dict] = [], optional_content: Optional[Dict] = None, output_json_path: str = None, always_write_output_json: bool = False, ipr_upload: bool = True, interactive: bool = False, graphkb_url: str = '', ) -> Optional[Dict]: Args username ( str ): the username for connecting to GraphKB and IPR password ( str ): the password for connecting to GraphKB and IPR patient_id ( str ) kb_disease_match ( str ): disease name to be used in matching to GraphKB project ( str ) ipr_url ( str ): base URL to use in connecting to IPR log_level ( str ): the logging level expression_variant_rows ( Iterable[Dict] ) structural_variant_rows ( Iterable[Dict] ) copy_variant_rows ( Iterable[Dict] ) small_mutation_rows ( Iterable[Dict] ) optional_content ( Optional[Dict] ): pass-through content to include in the JSON upload output_json_path ( str ): path to a JSON file to output the report upload body. always_write_output_json ( bool ): with successful IPR upload ipr_upload ( bool ): upload report to ipr interactive ( bool ): progressbars for interactive users graphkb_url ( str ) Returns Optional[Dict] : ipr_conn.upload_report return dictionary","title":"ipr.main"},{"location":"reference/ipr/main/#iprmain","text":"","title":"ipr.main"},{"location":"reference/ipr/main/#cache_gene_minimum","text":"CACHE_GENE_MINIMUM = 5000","title":"CACHE_GENE_MINIMUM"},{"location":"reference/ipr/main/#clean_unsupported_content","text":"Remove unsupported content. This content is either added to facilitate creation or to support upcoming and soon to be supported content that we would like to implement but is not yet supported by the upload def clean_unsupported_content(upload_content: Dict) -> Dict: Args upload_content ( Dict ) Returns Dict","title":"clean_unsupported_content()"},{"location":"reference/ipr/main/#create_report","text":"Run the matching and create the report JSON for upload to IPR def create_report( username: str, password: str, patient_id: str, kb_disease_match: str, project: str = 'TEST', ipr_url: str = DEFAULT_URL, log_level: str = 'info', expression_variant_rows: Iterable[Dict] = [], structural_variant_rows: Iterable[Dict] = [], copy_variant_rows: Iterable[Dict] = [], small_mutation_rows: Iterable[Dict] = [], optional_content: Optional[Dict] = None, output_json_path: str = None, always_write_output_json: bool = False, ipr_upload: bool = True, interactive: bool = False, graphkb_url: str = '', ) -> Optional[Dict]: Args username ( str ): the username for connecting to GraphKB and IPR password ( str ): the password for connecting to GraphKB and IPR patient_id ( str ) kb_disease_match ( str ): disease name to be used in matching to GraphKB project ( str ) ipr_url ( str ): base URL to use in connecting to IPR log_level ( str ): the logging level expression_variant_rows ( Iterable[Dict] ) structural_variant_rows ( Iterable[Dict] ) copy_variant_rows ( Iterable[Dict] ) small_mutation_rows ( Iterable[Dict] ) optional_content ( Optional[Dict] ): pass-through content to include in the JSON upload output_json_path ( str ): path to a JSON file to output the report upload body. always_write_output_json ( bool ): with successful IPR upload ipr_upload ( bool ): upload report to ipr interactive ( bool ): progressbars for interactive users graphkb_url ( str ) Returns Optional[Dict] : ipr_conn.upload_report return dictionary","title":"create_report()"},{"location":"reference/ipr/summary/","text":"ipr.summary OTHER_DISEASES OTHER_DISEASES = 'other disease types' ENTREZ_GENE_URL ENTREZ_GENE_URL = 'https://www.ncbi.nlm.nih.gov/gene' GRAPHKB_GUI GRAPHKB_GUI = 'https://graphkb.bcgsc.ca' filter_by_record_class() Given a list of records, return the subset matching a class or list of classes def filter_by_record_class( record_list: List[Dict], *record_classes, exclude: bool = False ) -> List[Dict]: Args record_list ( List[Dict] ) Returns List[Dict] create_graphkb_link() Create a link for a set of statements to the GraphKB client def create_graphkb_link( record_ids: List[str], record_class: str = 'Statement', ) -> str: Args record_ids ( List[str] ) record_class ( str ) Returns str substitute_sentence_template() Create the filled-in sentence template for a given template and list of substitutions which may be the result of the aggregation of 1 or more statements def substitute_sentence_template( template: str, conditions: List[Record], subjects: List[Record], relevance: Record, evidence: List[Record], statement_rids: List[str] = [], disease_matches: Set[str] = set(), ) -> str: Args template ( str ) conditions ( List[Record] ) subjects ( List[Record] ) relevance ( Record ) evidence ( List[Record] ) statement_rids ( List[str] ) disease_matches ( Set[str] ) Returns str aggregate_statements() Group Statements that only differ in disease conditions and evidence def aggregate_statements( graphkb_conn: GraphKBConnection, template: str, statements: List[Statement], disease_matches: Set[str], ) -> Dict[str, str]: Args graphkb_conn ( GraphKBConnection ) template ( str ) statements ( List[Statement] ) disease_matches ( Set[str] ) Returns Dict[str, str] create_section_html() Generate HTML for a gene section of the comments def create_section_html( graphkb_conn: GraphKBConnection, gene_name: str, sentences_by_statement_id: Dict[str, str], statements: Dict[str, Statement], exp_variants: List[IprVariant], ) -> str: Args graphkb_conn ( GraphKBConnection ) gene_name ( str ) sentences_by_statement_id ( Dict[str, str] ) statements ( Dict[str, Statement] ) exp_variants (List[ IprVariant ]) Returns str section_statements_by_genes() Determine the statements associated with each gene name def section_statements_by_genes( graphkb_conn: GraphKBConnection, statements: Sequence[Statement] ) -> Dict[str, Set[str]]: Args graphkb_conn ( GraphKBConnection ) statements ( Sequence[Statement] ) Returns Dict[str, Set[str]] summarize() Given a list of GraphKB matches generate a text summary to add to the report def summarize( graphkb_conn: GraphKBConnection, matches: Sequence[KbMatch], disease_name: str, variants: List[IprVariant], ) -> str: Args graphkb_conn ( GraphKBConnection ) matches (Sequence[ KbMatch ]) disease_name ( str ) variants (List[ IprVariant ]) Returns str","title":"ipr.summary"},{"location":"reference/ipr/summary/#iprsummary","text":"","title":"ipr.summary"},{"location":"reference/ipr/summary/#other_diseases","text":"OTHER_DISEASES = 'other disease types'","title":"OTHER_DISEASES"},{"location":"reference/ipr/summary/#entrez_gene_url","text":"ENTREZ_GENE_URL = 'https://www.ncbi.nlm.nih.gov/gene'","title":"ENTREZ_GENE_URL"},{"location":"reference/ipr/summary/#graphkb_gui","text":"GRAPHKB_GUI = 'https://graphkb.bcgsc.ca'","title":"GRAPHKB_GUI"},{"location":"reference/ipr/summary/#filter_by_record_class","text":"Given a list of records, return the subset matching a class or list of classes def filter_by_record_class( record_list: List[Dict], *record_classes, exclude: bool = False ) -> List[Dict]: Args record_list ( List[Dict] ) Returns List[Dict]","title":"filter_by_record_class()"},{"location":"reference/ipr/summary/#create_graphkb_link","text":"Create a link for a set of statements to the GraphKB client def create_graphkb_link( record_ids: List[str], record_class: str = 'Statement', ) -> str: Args record_ids ( List[str] ) record_class ( str ) Returns str","title":"create_graphkb_link()"},{"location":"reference/ipr/summary/#substitute_sentence_template","text":"Create the filled-in sentence template for a given template and list of substitutions which may be the result of the aggregation of 1 or more statements def substitute_sentence_template( template: str, conditions: List[Record], subjects: List[Record], relevance: Record, evidence: List[Record], statement_rids: List[str] = [], disease_matches: Set[str] = set(), ) -> str: Args template ( str ) conditions ( List[Record] ) subjects ( List[Record] ) relevance ( Record ) evidence ( List[Record] ) statement_rids ( List[str] ) disease_matches ( Set[str] ) Returns str","title":"substitute_sentence_template()"},{"location":"reference/ipr/summary/#aggregate_statements","text":"Group Statements that only differ in disease conditions and evidence def aggregate_statements( graphkb_conn: GraphKBConnection, template: str, statements: List[Statement], disease_matches: Set[str], ) -> Dict[str, str]: Args graphkb_conn ( GraphKBConnection ) template ( str ) statements ( List[Statement] ) disease_matches ( Set[str] ) Returns Dict[str, str]","title":"aggregate_statements()"},{"location":"reference/ipr/summary/#create_section_html","text":"Generate HTML for a gene section of the comments def create_section_html( graphkb_conn: GraphKBConnection, gene_name: str, sentences_by_statement_id: Dict[str, str], statements: Dict[str, Statement], exp_variants: List[IprVariant], ) -> str: Args graphkb_conn ( GraphKBConnection ) gene_name ( str ) sentences_by_statement_id ( Dict[str, str] ) statements ( Dict[str, Statement] ) exp_variants (List[ IprVariant ]) Returns str","title":"create_section_html()"},{"location":"reference/ipr/summary/#section_statements_by_genes","text":"Determine the statements associated with each gene name def section_statements_by_genes( graphkb_conn: GraphKBConnection, statements: Sequence[Statement] ) -> Dict[str, Set[str]]: Args graphkb_conn ( GraphKBConnection ) statements ( Sequence[Statement] ) Returns Dict[str, Set[str]]","title":"section_statements_by_genes()"},{"location":"reference/ipr/summary/#summarize","text":"Given a list of GraphKB matches generate a text summary to add to the report def summarize( graphkb_conn: GraphKBConnection, matches: Sequence[KbMatch], disease_name: str, variants: List[IprVariant], ) -> str: Args graphkb_conn ( GraphKBConnection ) matches (Sequence[ KbMatch ]) disease_name ( str ) variants (List[ IprVariant ]) Returns str","title":"summarize()"},{"location":"reference/ipr/therapeutic_options/","text":"ipr.therapeutic_options upload variant and report information to IPR create_therapeutic_options() Generate therapeutic options summary from the list of kb-matches def create_therapeutic_options( graphkb_conn: GraphKBConnection, kb_matches: List[KbMatch], variants: List[IprVariant] ) -> List[Dict]: Args graphkb_conn ( GraphKBConnection ) kb_matches (List[ KbMatch ]) variants (List[ IprVariant ]) Returns List[Dict]","title":"ipr.therapeutic_options"},{"location":"reference/ipr/therapeutic_options/#iprtherapeutic_options","text":"upload variant and report information to IPR","title":"ipr.therapeutic_options"},{"location":"reference/ipr/therapeutic_options/#create_therapeutic_options","text":"Generate therapeutic options summary from the list of kb-matches def create_therapeutic_options( graphkb_conn: GraphKBConnection, kb_matches: List[KbMatch], variants: List[IprVariant] ) -> List[Dict]: Args graphkb_conn ( GraphKBConnection ) kb_matches (List[ KbMatch ]) variants (List[ IprVariant ]) Returns List[Dict]","title":"create_therapeutic_options()"},{"location":"reference/ipr/types/","text":"ipr.types IprVariant IprVariant = Union[IprGeneVariant, IprStructuralVariant] class KbMatch inherits TypedDict Attributes variant ( str ) variantType ( str ) approvedTherapy ( bool ) category ( str ) context ( str ) kbContextId ( str ) disease ( str ) evidenceLevel ( str ) kbStatementId ( str ) kbVariant ( str ) kbVariantId ( str ) matchedCancer ( bool ) reference ( str ) relevance ( str ) kbRelevanceId ( str ) class IprGeneVariant inherits TypedDict Attributes gene ( str ) key ( str ) variantType ( str ) variant ( str ) class IprGene inherits TypedDict Attributes name ( str ) cancerRelated ( Optional[bool] ) knownFusionPartner ( Optional[bool] ) knownSmallMutation ( Optional[bool] ) tumourSuppressor ( Optional[bool] ) oncogene ( Optional[bool] ) therapeuticAssociated ( Optional[bool] ) class IprStructuralVariant inherits TypedDict Attributes key ( str ) variantType ( str ) variant ( str ) gene1 ( str ) gene2 ( str ) exon1 ( int ) exon2 ( int ) class ImageDefinition inherits TypedDict Attributes key ( str ) path ( str )","title":"ipr.types"},{"location":"reference/ipr/types/#iprtypes","text":"","title":"ipr.types"},{"location":"reference/ipr/types/#iprvariant","text":"IprVariant = Union[IprGeneVariant, IprStructuralVariant]","title":"IprVariant"},{"location":"reference/ipr/types/#class-kbmatch","text":"inherits TypedDict Attributes variant ( str ) variantType ( str ) approvedTherapy ( bool ) category ( str ) context ( str ) kbContextId ( str ) disease ( str ) evidenceLevel ( str ) kbStatementId ( str ) kbVariant ( str ) kbVariantId ( str ) matchedCancer ( bool ) reference ( str ) relevance ( str ) kbRelevanceId ( str )","title":"class KbMatch"},{"location":"reference/ipr/types/#class-iprgenevariant","text":"inherits TypedDict Attributes gene ( str ) key ( str ) variantType ( str ) variant ( str )","title":"class IprGeneVariant"},{"location":"reference/ipr/types/#class-iprgene","text":"inherits TypedDict Attributes name ( str ) cancerRelated ( Optional[bool] ) knownFusionPartner ( Optional[bool] ) knownSmallMutation ( Optional[bool] ) tumourSuppressor ( Optional[bool] ) oncogene ( Optional[bool] ) therapeuticAssociated ( Optional[bool] )","title":"class IprGene"},{"location":"reference/ipr/types/#class-iprstructuralvariant","text":"inherits TypedDict Attributes key ( str ) variantType ( str ) variant ( str ) gene1 ( str ) gene2 ( str ) exon1 ( int ) exon2 ( int )","title":"class IprStructuralVariant"},{"location":"reference/ipr/types/#class-imagedefinition","text":"inherits TypedDict Attributes key ( str ) path ( str )","title":"class ImageDefinition"},{"location":"reference/ipr/util/","text":"ipr.util VERBOSE_ERROR_CODE VERBOSE_ERROR_CODE = (logging.INFO + logging.DEBUG) // 2 logger logger = logging.getLogger('ipr') LOG_LEVELS LOG_LEVELS = { 'info': logging.INFO, 'debug': logging.DEBUG, 'warn': logging.WARN, 'error': logging.ERROR, 'verbose': VERBOSE_ERROR_CODE, create_variant_name() Given an IPR variant row, create the variant representation to be used as the name of the variant def create_variant_name(variant: IprVariant) -> str: Args variant ( IprVariant ) Returns str create_variant_name_tuple() Given an IPR variant row, create the variant representation to be used as the name of the variant def create_variant_name_tuple(variant: IprVariant) -> Tuple[str, str]: Args variant ( IprVariant ) Returns Tuple[str, str] find_variant() Find a variant in a list of variants by its key and type def find_variant(all_variants: List[IprVariant], variant_type: str, variant_key: str) -> IprVariant: Args all_variants (List[ IprVariant ]) variant_type ( str ) variant_key ( str ) Returns IprVariant generate_ontology_preference_key() Generate a tuple key for comparing preferred ontology terms. def generate_ontology_preference_key(record: Dict, sources_sort: Dict[str, int] = {}) -> Tuple: Args record ( Dict ) sources_sort ( Dict[str, int] ) Returns Tuple get_preferred_drug_representation() Given a Drug record, follow its linked records to find the preferred representation by following alias, deprecating, and cross reference links def get_preferred_drug_representation(graphkb_conn: GraphKBConnection, drug_record_id: str) -> Dict: Args graphkb_conn ( GraphKBConnection ) drug_record_id ( str ) Returns Dict get_preferred_gene_name() Given some Feature record ID return the preferred gene name def get_preferred_gene_name(graphkb_conn: GraphKBConnection, record_id: str) -> str: Args graphkb_conn ( GraphKBConnection ) record_id ( str ) Returns str","title":"ipr.util"},{"location":"reference/ipr/util/#iprutil","text":"","title":"ipr.util"},{"location":"reference/ipr/util/#verbose_error_code","text":"VERBOSE_ERROR_CODE = (logging.INFO + logging.DEBUG) // 2","title":"VERBOSE_ERROR_CODE"},{"location":"reference/ipr/util/#logger","text":"logger = logging.getLogger('ipr')","title":"logger"},{"location":"reference/ipr/util/#log_levels","text":"LOG_LEVELS = { 'info': logging.INFO, 'debug': logging.DEBUG, 'warn': logging.WARN, 'error': logging.ERROR, 'verbose': VERBOSE_ERROR_CODE,","title":"LOG_LEVELS"},{"location":"reference/ipr/util/#create_variant_name","text":"Given an IPR variant row, create the variant representation to be used as the name of the variant def create_variant_name(variant: IprVariant) -> str: Args variant ( IprVariant ) Returns str","title":"create_variant_name()"},{"location":"reference/ipr/util/#create_variant_name_tuple","text":"Given an IPR variant row, create the variant representation to be used as the name of the variant def create_variant_name_tuple(variant: IprVariant) -> Tuple[str, str]: Args variant ( IprVariant ) Returns Tuple[str, str]","title":"create_variant_name_tuple()"},{"location":"reference/ipr/util/#find_variant","text":"Find a variant in a list of variants by its key and type def find_variant(all_variants: List[IprVariant], variant_type: str, variant_key: str) -> IprVariant: Args all_variants (List[ IprVariant ]) variant_type ( str ) variant_key ( str ) Returns IprVariant","title":"find_variant()"},{"location":"reference/ipr/util/#generate_ontology_preference_key","text":"Generate a tuple key for comparing preferred ontology terms. def generate_ontology_preference_key(record: Dict, sources_sort: Dict[str, int] = {}) -> Tuple: Args record ( Dict ) sources_sort ( Dict[str, int] ) Returns Tuple","title":"generate_ontology_preference_key()"},{"location":"reference/ipr/util/#get_preferred_drug_representation","text":"Given a Drug record, follow its linked records to find the preferred representation by following alias, deprecating, and cross reference links def get_preferred_drug_representation(graphkb_conn: GraphKBConnection, drug_record_id: str) -> Dict: Args graphkb_conn ( GraphKBConnection ) drug_record_id ( str ) Returns Dict","title":"get_preferred_drug_representation()"},{"location":"reference/ipr/util/#get_preferred_gene_name","text":"Given some Feature record ID return the preferred gene name def get_preferred_gene_name(graphkb_conn: GraphKBConnection, record_id: str) -> str: Args graphkb_conn ( GraphKBConnection ) record_id ( str ) Returns str","title":"get_preferred_gene_name()"}]}