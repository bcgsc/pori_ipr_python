{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Genomic Report User Manual The Genomic Report python package is a tool for generating an IPR report with GraphKB annotations. Lists of variants are parsed, annotated, and then uploaded as part of a report. Getting Started Install the package with pip pip install genomic_report This will require python 3.6 or greater. this can now be used as a command line tool genomic_report -h or as part of a script from argparse import Namespace from genomic_report.main import create_report create_report(...)","title":"Home"},{"location":"#genomic-report-user-manual","text":"The Genomic Report python package is a tool for generating an IPR report with GraphKB annotations. Lists of variants are parsed, annotated, and then uploaded as part of a report.","title":"Genomic Report User Manual"},{"location":"#getting-started","text":"Install the package with pip pip install genomic_report This will require python 3.6 or greater. this can now be used as a command line tool genomic_report -h or as part of a script from argparse import Namespace from genomic_report.main import create_report create_report(...)","title":"Getting Started"},{"location":"variant_inputs/","text":"Variant Input Files The reference documentation for genomic_report.inputs contains the function signatures. This document is focused on users building the files. All variant files for the genomic report use a tab delimited format. The column names, types and example inputs are shown below. Expression Variant Data Required Columns Column Type Description gene string the gene name (or source identifier) kbCategory string the graphkb expression variant vocabulary term this variant belongs to expressionState string the variant used for display in the report Optional Columns Column Type Description rnaReads float rpkm float foldChange float tcgaPerc float percentile value when compared to the primary disease comparator tcgaPercCol string primary disease comparator tcgakIQR float kIQR value when compared to the primary disease comparator tcgaQC float tcgaQCCol string tcgaAvgPerc float tcgaAvgkIQR float tcgaAvgQC float tcgaAvgQCCol string tcgaNormPerc float tcgaNormkIQR float ptxPerc float ptxkIQR float ptxQC float ptxPercCol string ptxTotSampObs integer ptxPogPerc float gtexComp string gtexPerc float gtexFC float gtexkIQR float gtexAvgPerc float gtexAvgFC float gtexAvgkIQR float Small Mutation Data Small mutations are composed of indels and single nucleotide variants. Required Columns Column Type Example Description location string 10:123456 the genomic position of this variant refAlt string A>T the genomic sequence change gene string KRAS the gene name proteinChange string p.G12D the HGVS protein notation transcript string ENST00001.2 the transcript name Optional Columns Column Type Example Description zygosity string het tumourReads string 4/8 the reference and alternate (supporting) read counts at this position in the genome rnaReads string 4/8 the reference and alternate (supporting) read counts at this position in the transcriptome detectedIn string DNA/RNA the sample types this variant was detected in hgvsCds string ENST0001:c.1234+3A>G HGVS coding sequence notation for this variant hgvsGenomic string 1:g.1234A>G HGVS genomic notation for this variant hgvsProtein string KRAS:p.G12D HGVS protein notation for this variant Copy Variant Data Required Columns Column Type Example Description gene string KRAS the gene name kbCategory string the graphkb copy variant vocabulary term this variant belongs to Optional Columns Column Type Example Description ploidyCorrCpyChange integer -2 the ploidy corrected copy change lohState string HET the loss-of-heterozygosity category for this gene region chromosomeBand string start integer the genomic start position of the copy segment this gene copy number was called from end integer the genomic end position of the copy segment this gene copy number was called from Structural Variant (Fusion) Data Required Columns Column Type Example Description eventType string deletion the type of underlying structural variant breakpoint string 12:123456|14:1244662 description of the breakpoints involved in this structural variant gene1 string EWSR1 the 5' (n-terminal) gene name gene2 string FLI1 the 3' (c-terminal) gene name exon1 integer 1 the 5' (n-terminal) exon exon2 integer 2 the 3' (c-terminal) exon nTermTranscript string ENST0001.2 the 3' transcript name ctermTranscript string ENST004.5 the 5' transcript name Optional Columns Column Type Example Description detectedIn string DNA the sample type(s) this SV was detected in conventionalName string cytogenic descriptor svg string svg image file for this SV svgTitle string title for the svg omicSupport boolean flag to indicate this SV has support from both genome and transcriptome","title":"Variant Inputs"},{"location":"variant_inputs/#variant-input-files","text":"The reference documentation for genomic_report.inputs contains the function signatures. This document is focused on users building the files. All variant files for the genomic report use a tab delimited format. The column names, types and example inputs are shown below.","title":"Variant Input Files"},{"location":"variant_inputs/#expression-variant-data","text":"","title":"Expression Variant Data"},{"location":"variant_inputs/#required-columns","text":"Column Type Description gene string the gene name (or source identifier) kbCategory string the graphkb expression variant vocabulary term this variant belongs to expressionState string the variant used for display in the report","title":"Required Columns"},{"location":"variant_inputs/#optional-columns","text":"Column Type Description rnaReads float rpkm float foldChange float tcgaPerc float percentile value when compared to the primary disease comparator tcgaPercCol string primary disease comparator tcgakIQR float kIQR value when compared to the primary disease comparator tcgaQC float tcgaQCCol string tcgaAvgPerc float tcgaAvgkIQR float tcgaAvgQC float tcgaAvgQCCol string tcgaNormPerc float tcgaNormkIQR float ptxPerc float ptxkIQR float ptxQC float ptxPercCol string ptxTotSampObs integer ptxPogPerc float gtexComp string gtexPerc float gtexFC float gtexkIQR float gtexAvgPerc float gtexAvgFC float gtexAvgkIQR float","title":"Optional Columns"},{"location":"variant_inputs/#small-mutation-data","text":"Small mutations are composed of indels and single nucleotide variants.","title":"Small Mutation Data"},{"location":"variant_inputs/#required-columns_1","text":"Column Type Example Description location string 10:123456 the genomic position of this variant refAlt string A>T the genomic sequence change gene string KRAS the gene name proteinChange string p.G12D the HGVS protein notation transcript string ENST00001.2 the transcript name","title":"Required Columns"},{"location":"variant_inputs/#optional-columns_1","text":"Column Type Example Description zygosity string het tumourReads string 4/8 the reference and alternate (supporting) read counts at this position in the genome rnaReads string 4/8 the reference and alternate (supporting) read counts at this position in the transcriptome detectedIn string DNA/RNA the sample types this variant was detected in hgvsCds string ENST0001:c.1234+3A>G HGVS coding sequence notation for this variant hgvsGenomic string 1:g.1234A>G HGVS genomic notation for this variant hgvsProtein string KRAS:p.G12D HGVS protein notation for this variant","title":"Optional Columns"},{"location":"variant_inputs/#copy-variant-data","text":"","title":"Copy Variant Data"},{"location":"variant_inputs/#required-columns_2","text":"Column Type Example Description gene string KRAS the gene name kbCategory string the graphkb copy variant vocabulary term this variant belongs to","title":"Required Columns"},{"location":"variant_inputs/#optional-columns_2","text":"Column Type Example Description ploidyCorrCpyChange integer -2 the ploidy corrected copy change lohState string HET the loss-of-heterozygosity category for this gene region chromosomeBand string start integer the genomic start position of the copy segment this gene copy number was called from end integer the genomic end position of the copy segment this gene copy number was called from","title":"Optional Columns"},{"location":"variant_inputs/#structural-variant-fusion-data","text":"","title":"Structural Variant (Fusion) Data"},{"location":"variant_inputs/#required-columns_3","text":"Column Type Example Description eventType string deletion the type of underlying structural variant breakpoint string 12:123456|14:1244662 description of the breakpoints involved in this structural variant gene1 string EWSR1 the 5' (n-terminal) gene name gene2 string FLI1 the 3' (c-terminal) gene name exon1 integer 1 the 5' (n-terminal) exon exon2 integer 2 the 3' (c-terminal) exon nTermTranscript string ENST0001.2 the 3' transcript name ctermTranscript string ENST004.5 the 5' transcript name","title":"Required Columns"},{"location":"variant_inputs/#optional-columns_3","text":"Column Type Example Description detectedIn string DNA the sample type(s) this SV was detected in conventionalName string cytogenic descriptor svg string svg image file for this SV svgTitle string title for the svg omicSupport boolean flag to indicate this SV has support from both genome and transcriptome","title":"Optional Columns"},{"location":"reference/ipr/annotate/","text":"ipr.annotate handles annotating variants with annotation information from graphkb get_gene_information() Create the Gene Info object for upload to IPR with the other report information def get_gene_information( graphkb_conn: GraphKBConnection, gene_names: Iterable[str] ) -> List[IprGene]: Args graphkb_conn ( GraphKBConnection ): [description] gene_names ( Iterable[str] ): [description] Returns List[ IprGene ] get_statements_from_variants() Given a list of variant records from GraphKB, return all the related statements def get_statements_from_variants( graphkb_conn: GraphKBConnection, variants: List[Record] ) -> List[Statement]: Args graphkb_conn ( GraphKBConnection ): the graphkb api connection object variants ( List[Record] ): list of variant records Returns List[Statement] : list of Statement records from graphkb get_ipr_statements_from_variants() Matches to GraphKB statements from the list of input variants. From these results matches again with the inferred variants. Then returns the results formatted for upload to IPR def get_ipr_statements_from_variants( graphkb_conn: GraphKBConnection, matches: List[Record], disease_name: str ) -> List[KbMatch]: Args graphkb_conn ( GraphKBConnection ) matches ( List[Record] ) disease_name ( str ) Returns List[ KbMatch ] annotate_category_variants() Annotate variant calls with information from GraphKB and return these annotations in the IPR alterations format def annotate_category_variants( graphkb_conn: GraphKBConnection, variants: List[IprGeneVariant], disease_name: str, copy_variant: bool = True, show_progress: bool = False, ) -> List[KbMatch]: Args graphkb_conn ( GraphKBConnection ): the graphkb api connection object variants (List[ IprGeneVariant ]): list of variants disease_name ( str ) copy_variant ( bool ) show_progress ( bool ) Returns List[ KbMatch ]: list of kbMatches records for IPR annotate_positional_variants() Annotate variant calls with information from GraphKB and return these annotations in the IPR alterations format def annotate_positional_variants( graphkb_conn: GraphKBConnection, variants: List[IprVariant], disease_name: str, show_progress: bool = False, ) -> List[KbMatch]: Args graphkb_conn ( GraphKBConnection ): the graphkb api connection object variants (List[ IprVariant ]): list of variants. Defaults to []. disease_name ( str ) show_progress ( bool ) Returns List[ KbMatch ]: list of kbMatches records for IPR","title":"ipr.annotate"},{"location":"reference/ipr/annotate/#iprannotate","text":"handles annotating variants with annotation information from graphkb","title":"ipr.annotate"},{"location":"reference/ipr/annotate/#get_gene_information","text":"Create the Gene Info object for upload to IPR with the other report information def get_gene_information( graphkb_conn: GraphKBConnection, gene_names: Iterable[str] ) -> List[IprGene]: Args graphkb_conn ( GraphKBConnection ): [description] gene_names ( Iterable[str] ): [description] Returns List[ IprGene ]","title":"get_gene_information()"},{"location":"reference/ipr/annotate/#get_statements_from_variants","text":"Given a list of variant records from GraphKB, return all the related statements def get_statements_from_variants( graphkb_conn: GraphKBConnection, variants: List[Record] ) -> List[Statement]: Args graphkb_conn ( GraphKBConnection ): the graphkb api connection object variants ( List[Record] ): list of variant records Returns List[Statement] : list of Statement records from graphkb","title":"get_statements_from_variants()"},{"location":"reference/ipr/annotate/#get_ipr_statements_from_variants","text":"Matches to GraphKB statements from the list of input variants. From these results matches again with the inferred variants. Then returns the results formatted for upload to IPR def get_ipr_statements_from_variants( graphkb_conn: GraphKBConnection, matches: List[Record], disease_name: str ) -> List[KbMatch]: Args graphkb_conn ( GraphKBConnection ) matches ( List[Record] ) disease_name ( str ) Returns List[ KbMatch ]","title":"get_ipr_statements_from_variants()"},{"location":"reference/ipr/annotate/#annotate_category_variants","text":"Annotate variant calls with information from GraphKB and return these annotations in the IPR alterations format def annotate_category_variants( graphkb_conn: GraphKBConnection, variants: List[IprGeneVariant], disease_name: str, copy_variant: bool = True, show_progress: bool = False, ) -> List[KbMatch]: Args graphkb_conn ( GraphKBConnection ): the graphkb api connection object variants (List[ IprGeneVariant ]): list of variants disease_name ( str ) copy_variant ( bool ) show_progress ( bool ) Returns List[ KbMatch ]: list of kbMatches records for IPR","title":"annotate_category_variants()"},{"location":"reference/ipr/annotate/#annotate_positional_variants","text":"Annotate variant calls with information from GraphKB and return these annotations in the IPR alterations format def annotate_positional_variants( graphkb_conn: GraphKBConnection, variants: List[IprVariant], disease_name: str, show_progress: bool = False, ) -> List[KbMatch]: Args graphkb_conn ( GraphKBConnection ): the graphkb api connection object variants (List[ IprVariant ]): list of variants. Defaults to []. disease_name ( str ) show_progress ( bool ) Returns List[ KbMatch ]: list of kbMatches records for IPR","title":"annotate_positional_variants()"},{"location":"reference/ipr/inputs/","text":"ipr.inputs Read/Validate the variant input files NULLABLE_FLOAT_REGEX NULLABLE_FLOAT_REGEX = r'^-?((inf)|(\\d+(\\.\\d+)?)|)$' COPY_REQ COPY_REQ = ['gene', 'kbCategory'] COPY_KEY COPY_KEY = ['gene'] COPY_OPTIONAL COPY_OPTIONAL = [ 'cnvState', 'ploidyCorrCpChange', 'lohState', # Loss of Heterzygosity state - informative detail to analyst 'chromosomeBand', 'start', 'end', ] SMALL_MUT_REQ SMALL_MUT_REQ = ['gene', 'proteinChange'] SMALL_MUT_KEY SMALL_MUT_KEY = SMALL_MUT_REQ + ['transcript', 'location', 'refAlt'] SMALL_MUT_OPTIONAL SMALL_MUT_OPTIONAL = [ 'zygosity', 'tumourReads', 'rnaReads', 'hgvsProtein', 'hgvsCds', 'hgvsGenomic', 'location', 'refAlt', 'transcript', ] EXP_REQ EXP_REQ = ['gene', 'kbCategory'] EXP_KEY EXP_KEY = ['gene'] EXP_OPTIONAL EXP_OPTIONAL = [ 'expressionState', 'rnaReads', 'rpkm', 'foldChange', 'tcgaPerc', 'tcgaPercCol', 'tcgakIQR', 'tcgaQC', 'tcgaQCCol', 'tcgaAvgPerc', 'tcgaAvgkIQR', 'tcgaAvgQC', 'tcgaAvgQCCol', 'tcgaNormPerc', 'tcgaNormkIQR', 'ptxPerc', 'ptxkIQR', 'ptxQC', 'ptxPercCol', 'ptxTotSampObs', 'ptxPogPerc', 'gtexComp', 'gtexPerc', 'gtexFC', 'gtexkIQR', 'gtexAvgPerc', 'gtexAvgFC', 'gtexAvgkIQR', 'histogramImage', ] SV_REQ SV_REQ = [ 'eventType', 'breakpoint', 'gene1', # prev: nterm_hugo 'gene2', # prev: cterm_hugo 'exon1', # n-terminal 'exon2', # c-terminal ] SV_KEY SV_KEY = SV_REQ[:] SV_OPTIONAL SV_OPTIONAL = [ 'ctermTranscript', 'ntermTranscript', 'ctermGene', # combined hugo ensembl form 'ntermGene', # combined hugo ensembl form 'detectedIn', 'conventionalName', 'svg', 'svgTitle', 'name', 'frame', 'omicSupport', 'highQuality', ] validate_variant_rows() check that the required columns are present check that a unique key can be formed for each row drop any non-defined columns def validate_variant_rows( rows: Iterable[Dict], required: List[str], optional: List[str], row_to_key: Callable ) -> List[IprVariant]: Args rows ( Iterable[Dict] ): the input files rows required ( List[str] ) optional ( List[str] ): list of optional column names row_to_key ( Callable ): function to generate a key for a given row Returns List[ IprVariant ]: the rows from the tab file as dictionaries Raises ValueError : row keys are not unique ValueError : A required column is missing read_tabbed_file() Load a tab delimited file as dictionary rows def read_tabbed_file(filename: str) -> List[Dict]: Args filename ( str ) Returns List[Dict] validate_row_patterns() Validate rows against a regex for some set of columns def validate_row_patterns( rows: List[IprVariant], patterns: Dict, row_key_columns: List[str] ) -> None: Args rows (List[ IprVariant ]): input rows read from a delimited file patterns ( Dict ): mapping of column names to regex patterns the column are expected to match row_key_columns ( List[str] ) Raises ValueError : A row does not match the expected pattern for a given column preprocess_copy_variants() Validate the input rows contain the minimum required fields and generate any default values where possible def preprocess_copy_variants(rows: Iterable[Dict]) -> List[IprVariant]: Args rows ( Iterable[Dict] ) Returns List[ IprVariant ] preprocess_small_mutations() Validate the input rows contain the minimum required fields and generate any default values where possible def preprocess_small_mutations(rows: Iterable[Dict]) -> List[IprGeneVariant]: Args rows ( Iterable[Dict] ) Returns List[ IprGeneVariant ] preprocess_expression_variants() Validate the input rows contain the minimum required fields and generate any default values where possible def preprocess_expression_variants(rows: Iterable[Dict]) -> List[IprGeneVariant]: Args rows ( Iterable[Dict] ) Returns List[ IprGeneVariant ] create_graphkb_sv_notation() Generate GKB style structural variant notation from a structural variant input row def create_graphkb_sv_notation(row: IprStructuralVariant) -> str: Args row ( IprStructuralVariant ) Returns str preprocess_structural_variants() Validate the input rows contain the minimum required fields and generate any default values where possible def preprocess_structural_variants(rows: Iterable[Dict]) -> List[IprVariant]: Args rows ( Iterable[Dict] ) Returns List[ IprVariant ] check_variant_links() Check matching information for any genes with variants. Warn about genes with only one experimental measure. def check_variant_links( small_mutations: List[IprGeneVariant], expression_variants: List[IprGeneVariant], copy_variants: List[IprGeneVariant], structural_variants: List[IprStructuralVariant], ) -> Set[str]: Args small_mutations (List[ IprGeneVariant ]): list of small mutations expression_variants (List[ IprGeneVariant ]): list of expression variants copy_variants (List[ IprGeneVariant ]): list of copy variants structural_variants (List[ IprStructuralVariant ]): list of structural variants Returns Set[str] : set of gene names with variants (used for filtering before upload to IPR)","title":"ipr.inputs"},{"location":"reference/ipr/inputs/#iprinputs","text":"Read/Validate the variant input files","title":"ipr.inputs"},{"location":"reference/ipr/inputs/#nullable_float_regex","text":"NULLABLE_FLOAT_REGEX = r'^-?((inf)|(\\d+(\\.\\d+)?)|)$'","title":"NULLABLE_FLOAT_REGEX"},{"location":"reference/ipr/inputs/#copy_req","text":"COPY_REQ = ['gene', 'kbCategory']","title":"COPY_REQ"},{"location":"reference/ipr/inputs/#copy_key","text":"COPY_KEY = ['gene']","title":"COPY_KEY"},{"location":"reference/ipr/inputs/#copy_optional","text":"COPY_OPTIONAL = [ 'cnvState', 'ploidyCorrCpChange', 'lohState', # Loss of Heterzygosity state - informative detail to analyst 'chromosomeBand', 'start', 'end', ]","title":"COPY_OPTIONAL"},{"location":"reference/ipr/inputs/#small_mut_req","text":"SMALL_MUT_REQ = ['gene', 'proteinChange']","title":"SMALL_MUT_REQ"},{"location":"reference/ipr/inputs/#small_mut_key","text":"SMALL_MUT_KEY = SMALL_MUT_REQ + ['transcript', 'location', 'refAlt']","title":"SMALL_MUT_KEY"},{"location":"reference/ipr/inputs/#small_mut_optional","text":"SMALL_MUT_OPTIONAL = [ 'zygosity', 'tumourReads', 'rnaReads', 'hgvsProtein', 'hgvsCds', 'hgvsGenomic', 'location', 'refAlt', 'transcript', ]","title":"SMALL_MUT_OPTIONAL"},{"location":"reference/ipr/inputs/#exp_req","text":"EXP_REQ = ['gene', 'kbCategory']","title":"EXP_REQ"},{"location":"reference/ipr/inputs/#exp_key","text":"EXP_KEY = ['gene']","title":"EXP_KEY"},{"location":"reference/ipr/inputs/#exp_optional","text":"EXP_OPTIONAL = [ 'expressionState', 'rnaReads', 'rpkm', 'foldChange', 'tcgaPerc', 'tcgaPercCol', 'tcgakIQR', 'tcgaQC', 'tcgaQCCol', 'tcgaAvgPerc', 'tcgaAvgkIQR', 'tcgaAvgQC', 'tcgaAvgQCCol', 'tcgaNormPerc', 'tcgaNormkIQR', 'ptxPerc', 'ptxkIQR', 'ptxQC', 'ptxPercCol', 'ptxTotSampObs', 'ptxPogPerc', 'gtexComp', 'gtexPerc', 'gtexFC', 'gtexkIQR', 'gtexAvgPerc', 'gtexAvgFC', 'gtexAvgkIQR', 'histogramImage', ]","title":"EXP_OPTIONAL"},{"location":"reference/ipr/inputs/#sv_req","text":"SV_REQ = [ 'eventType', 'breakpoint', 'gene1', # prev: nterm_hugo 'gene2', # prev: cterm_hugo 'exon1', # n-terminal 'exon2', # c-terminal ]","title":"SV_REQ"},{"location":"reference/ipr/inputs/#sv_key","text":"SV_KEY = SV_REQ[:]","title":"SV_KEY"},{"location":"reference/ipr/inputs/#sv_optional","text":"SV_OPTIONAL = [ 'ctermTranscript', 'ntermTranscript', 'ctermGene', # combined hugo ensembl form 'ntermGene', # combined hugo ensembl form 'detectedIn', 'conventionalName', 'svg', 'svgTitle', 'name', 'frame', 'omicSupport', 'highQuality', ]","title":"SV_OPTIONAL"},{"location":"reference/ipr/inputs/#validate_variant_rows","text":"check that the required columns are present check that a unique key can be formed for each row drop any non-defined columns def validate_variant_rows( rows: Iterable[Dict], required: List[str], optional: List[str], row_to_key: Callable ) -> List[IprVariant]: Args rows ( Iterable[Dict] ): the input files rows required ( List[str] ) optional ( List[str] ): list of optional column names row_to_key ( Callable ): function to generate a key for a given row Returns List[ IprVariant ]: the rows from the tab file as dictionaries Raises ValueError : row keys are not unique ValueError : A required column is missing","title":"validate_variant_rows()"},{"location":"reference/ipr/inputs/#read_tabbed_file","text":"Load a tab delimited file as dictionary rows def read_tabbed_file(filename: str) -> List[Dict]: Args filename ( str ) Returns List[Dict]","title":"read_tabbed_file()"},{"location":"reference/ipr/inputs/#validate_row_patterns","text":"Validate rows against a regex for some set of columns def validate_row_patterns( rows: List[IprVariant], patterns: Dict, row_key_columns: List[str] ) -> None: Args rows (List[ IprVariant ]): input rows read from a delimited file patterns ( Dict ): mapping of column names to regex patterns the column are expected to match row_key_columns ( List[str] ) Raises ValueError : A row does not match the expected pattern for a given column","title":"validate_row_patterns()"},{"location":"reference/ipr/inputs/#preprocess_copy_variants","text":"Validate the input rows contain the minimum required fields and generate any default values where possible def preprocess_copy_variants(rows: Iterable[Dict]) -> List[IprVariant]: Args rows ( Iterable[Dict] ) Returns List[ IprVariant ]","title":"preprocess_copy_variants()"},{"location":"reference/ipr/inputs/#preprocess_small_mutations","text":"Validate the input rows contain the minimum required fields and generate any default values where possible def preprocess_small_mutations(rows: Iterable[Dict]) -> List[IprGeneVariant]: Args rows ( Iterable[Dict] ) Returns List[ IprGeneVariant ]","title":"preprocess_small_mutations()"},{"location":"reference/ipr/inputs/#preprocess_expression_variants","text":"Validate the input rows contain the minimum required fields and generate any default values where possible def preprocess_expression_variants(rows: Iterable[Dict]) -> List[IprGeneVariant]: Args rows ( Iterable[Dict] ) Returns List[ IprGeneVariant ]","title":"preprocess_expression_variants()"},{"location":"reference/ipr/inputs/#create_graphkb_sv_notation","text":"Generate GKB style structural variant notation from a structural variant input row def create_graphkb_sv_notation(row: IprStructuralVariant) -> str: Args row ( IprStructuralVariant ) Returns str","title":"create_graphkb_sv_notation()"},{"location":"reference/ipr/inputs/#preprocess_structural_variants","text":"Validate the input rows contain the minimum required fields and generate any default values where possible def preprocess_structural_variants(rows: Iterable[Dict]) -> List[IprVariant]: Args rows ( Iterable[Dict] ) Returns List[ IprVariant ]","title":"preprocess_structural_variants()"},{"location":"reference/ipr/inputs/#check_variant_links","text":"Check matching information for any genes with variants. Warn about genes with only one experimental measure. def check_variant_links( small_mutations: List[IprGeneVariant], expression_variants: List[IprGeneVariant], copy_variants: List[IprGeneVariant], structural_variants: List[IprStructuralVariant], ) -> Set[str]: Args small_mutations (List[ IprGeneVariant ]): list of small mutations expression_variants (List[ IprGeneVariant ]): list of expression variants copy_variants (List[ IprGeneVariant ]): list of copy variants structural_variants (List[ IprStructuralVariant ]): list of structural variants Returns Set[str] : set of gene names with variants (used for filtering before upload to IPR)","title":"check_variant_links()"},{"location":"reference/ipr/ipr/","text":"ipr.ipr upload variant and report information to IPR REPORT_KB_SECTIONS REPORT_KB_SECTIONS = IterableNamespace( therapeutic='therapeutic', prognostic='prognostic', biological='biological', unknown='unknown', novel='novel', diagnostic='diagnostic', ) APPROVED_EVIDENCE_LEVELS APPROVED_EVIDENCE_LEVELS = { # sourceIds of levels by source name 'oncokb': ['1', 'r1'], 'profyle': ['t1'], 'cancer genome interpreter': [ 'cpic guidelines', 'european leukemianet guidelines', 'fda guidelines', 'nccn guidelines', 'nccn/cap guidelines', DEFAULT_URL DEFAULT_URL = 'https://iprstaging-api.bcgsc.ca/api' DEFAULT_LIMIT DEFAULT_LIMIT = 1000 class IprConnection IprConnection.request() Request wrapper to handle adding common headers and logging def request(self, endpoint: str, method: str = 'GET', **kwargs) -> Dict: Args endpoint ( str ): api endpoint, excluding the base uri method ( str ): the http method. Defaults to 'GET'. Returns Dict : the json response as a python dict IprConnection.post() Convenience method for making post requests def post(self, uri: str, data: Dict = {}, **kwargs) -> Dict: Args uri ( str ) data ( Dict ) Returns Dict IprConnection.set_analyst_comments() Update report comments to an existing report TODO: Add to main upload. Pending: https://www.bcgsc.ca/jira/browse/DEVSU-1177 def set_analyst_comments(self, report_id: str, data: Dict) -> Dict: Args report_id ( str ) data ( Dict ) Returns Dict filter_structural_variants() Filter structural variants to remove non-high quality events unless they are matched/annotated or they involve a gene that is a known fusion partner def filter_structural_variants( structural_variants: List[IprStructuralVariant], kb_matches: List[KbMatch], gene_annotations: List[IprGene], ) -> List[IprStructuralVariant]: Args structural_variants (List[ IprStructuralVariant ]) kb_matches (List[ KbMatch ]) gene_annotations (List[ IprGene ]) Returns List[ IprStructuralVariant ] convert_statements_to_alterations() Given a set of statements matched from graphkb, convert these into their IPR equivalent representations def convert_statements_to_alterations( graphkb_conn: GraphKBConnection, statements: List[Statement], disease_name: str, variant_matches: Iterable[str], ) -> List[KbMatch]: Args graphkb_conn ( GraphKBConnection ): the graphkb connection object statements ( List[Statement] ): list of statement records from graphkb disease_name ( str ): name of the cancer type for the patient being reported on variant_matches ( Iterable[str] ): the list of RIDs the variant matched for these statements Returns List[ KbMatch ]: IPR graphkb row representations Notes: - only report disease matched prognostic markers https://www.bcgsc.ca/jira/browse/GERO-72 Raises ValueError : could not find the disease type in GraphKB find_variant() Find a variant in a list of variants by its key and type def find_variant(all_variants: List[IprVariant], variant_type: str, variant_key: str) -> IprVariant: Args all_variants (List[ IprVariant ]) variant_type ( str ) variant_key ( str ) Returns IprVariant select_expression_plots() Given the list of expression variants, determine which expression historgram plots should be included in the IPR upload. This filters them based on the graphkb annotations to avoid loading more images than are required def select_expression_plots( kb_matches: List[KbMatch], all_variants: List[IprVariant] ) -> List[Dict[str, ImageDefinition]]: Args kb_matches (List[ KbMatch ]): the IPR graphkb annoations for all variants all_variants (List[ IprVariant ]) Returns List[Dict[ str , ImageDefinition ]]: list of expression images to be loaded by IPR create_key_alterations() Creates the list of genomic key alterations which summarizes all the variants matched by the KB This list of matches is also used to create the variant counts def create_key_alterations( kb_matches: List[KbMatch], all_variants: List[IprVariant], ) -> Tuple[List[Dict], Dict]: Args kb_matches (List[ KbMatch ]) all_variants (List[ IprVariant ]) Returns Tuple[List[Dict], Dict]","title":"ipr.ipr"},{"location":"reference/ipr/ipr/#ipripr","text":"upload variant and report information to IPR","title":"ipr.ipr"},{"location":"reference/ipr/ipr/#report_kb_sections","text":"REPORT_KB_SECTIONS = IterableNamespace( therapeutic='therapeutic', prognostic='prognostic', biological='biological', unknown='unknown', novel='novel', diagnostic='diagnostic', )","title":"REPORT_KB_SECTIONS"},{"location":"reference/ipr/ipr/#approved_evidence_levels","text":"APPROVED_EVIDENCE_LEVELS = { # sourceIds of levels by source name 'oncokb': ['1', 'r1'], 'profyle': ['t1'], 'cancer genome interpreter': [ 'cpic guidelines', 'european leukemianet guidelines', 'fda guidelines', 'nccn guidelines', 'nccn/cap guidelines',","title":"APPROVED_EVIDENCE_LEVELS"},{"location":"reference/ipr/ipr/#default_url","text":"DEFAULT_URL = 'https://iprstaging-api.bcgsc.ca/api'","title":"DEFAULT_URL"},{"location":"reference/ipr/ipr/#default_limit","text":"DEFAULT_LIMIT = 1000","title":"DEFAULT_LIMIT"},{"location":"reference/ipr/ipr/#class-iprconnection","text":"","title":"class IprConnection"},{"location":"reference/ipr/ipr/#iprconnectionrequest","text":"Request wrapper to handle adding common headers and logging def request(self, endpoint: str, method: str = 'GET', **kwargs) -> Dict: Args endpoint ( str ): api endpoint, excluding the base uri method ( str ): the http method. Defaults to 'GET'. Returns Dict : the json response as a python dict","title":"IprConnection.request()"},{"location":"reference/ipr/ipr/#iprconnectionpost","text":"Convenience method for making post requests def post(self, uri: str, data: Dict = {}, **kwargs) -> Dict: Args uri ( str ) data ( Dict ) Returns Dict","title":"IprConnection.post()"},{"location":"reference/ipr/ipr/#iprconnectionset_analyst_comments","text":"Update report comments to an existing report TODO: Add to main upload. Pending: https://www.bcgsc.ca/jira/browse/DEVSU-1177 def set_analyst_comments(self, report_id: str, data: Dict) -> Dict: Args report_id ( str ) data ( Dict ) Returns Dict","title":"IprConnection.set_analyst_comments()"},{"location":"reference/ipr/ipr/#filter_structural_variants","text":"Filter structural variants to remove non-high quality events unless they are matched/annotated or they involve a gene that is a known fusion partner def filter_structural_variants( structural_variants: List[IprStructuralVariant], kb_matches: List[KbMatch], gene_annotations: List[IprGene], ) -> List[IprStructuralVariant]: Args structural_variants (List[ IprStructuralVariant ]) kb_matches (List[ KbMatch ]) gene_annotations (List[ IprGene ]) Returns List[ IprStructuralVariant ]","title":"filter_structural_variants()"},{"location":"reference/ipr/ipr/#convert_statements_to_alterations","text":"Given a set of statements matched from graphkb, convert these into their IPR equivalent representations def convert_statements_to_alterations( graphkb_conn: GraphKBConnection, statements: List[Statement], disease_name: str, variant_matches: Iterable[str], ) -> List[KbMatch]: Args graphkb_conn ( GraphKBConnection ): the graphkb connection object statements ( List[Statement] ): list of statement records from graphkb disease_name ( str ): name of the cancer type for the patient being reported on variant_matches ( Iterable[str] ): the list of RIDs the variant matched for these statements Returns List[ KbMatch ]: IPR graphkb row representations Notes: - only report disease matched prognostic markers https://www.bcgsc.ca/jira/browse/GERO-72 Raises ValueError : could not find the disease type in GraphKB","title":"convert_statements_to_alterations()"},{"location":"reference/ipr/ipr/#find_variant","text":"Find a variant in a list of variants by its key and type def find_variant(all_variants: List[IprVariant], variant_type: str, variant_key: str) -> IprVariant: Args all_variants (List[ IprVariant ]) variant_type ( str ) variant_key ( str ) Returns IprVariant","title":"find_variant()"},{"location":"reference/ipr/ipr/#select_expression_plots","text":"Given the list of expression variants, determine which expression historgram plots should be included in the IPR upload. This filters them based on the graphkb annotations to avoid loading more images than are required def select_expression_plots( kb_matches: List[KbMatch], all_variants: List[IprVariant] ) -> List[Dict[str, ImageDefinition]]: Args kb_matches (List[ KbMatch ]): the IPR graphkb annoations for all variants all_variants (List[ IprVariant ]) Returns List[Dict[ str , ImageDefinition ]]: list of expression images to be loaded by IPR","title":"select_expression_plots()"},{"location":"reference/ipr/ipr/#create_key_alterations","text":"Creates the list of genomic key alterations which summarizes all the variants matched by the KB This list of matches is also used to create the variant counts def create_key_alterations( kb_matches: List[KbMatch], all_variants: List[IprVariant], ) -> Tuple[List[Dict], Dict]: Args kb_matches (List[ KbMatch ]) all_variants (List[ IprVariant ]) Returns Tuple[List[Dict], Dict]","title":"create_key_alterations()"},{"location":"reference/ipr/main/","text":"ipr.main CACHE_GENE_MINIMUM CACHE_GENE_MINIMUM = 5000 clean_unsupported_content() Remove unsupported content. This content is either added to facilitate creation or to support upcoming and soon to be supported content that we would like to implement but is not yet supported by the upload def clean_unsupported_content(upload_content: Dict) -> Dict: Args upload_content ( Dict ) Returns Dict create_report() Run the matching and create the report JSON for upload to IPR def create_report( username: str, password: str, patient_id: str, kb_disease_match: str, project: str = 'TEST', ipr_url: str = ipr.DEFAULT_URL, log_level: str = 'info', expression_variant_rows: Iterable[Dict] = [], structural_variant_rows: Iterable[Dict] = [], copy_variant_rows: Iterable[Dict] = [], small_mutation_rows: Iterable[Dict] = [], optional_content: Optional[Dict] = None, output_json_path: str = None, always_write_output_json: bool = False, ipr_upload: bool = True, interactive: bool = False, cache_gene_minimum: int = CACHE_GENE_MINIMUM, graphkb_url: str = '', ) -> Optional[Dict]: Args username ( str ): the username for connecting to GraphKB and IPR password ( str ): the password for connecting to GraphKB and IPR patient_id ( str ) kb_disease_match ( str ): disease name to be used in matching to GraphKB project ( str ) ipr_url ( str ): base URL to use in connecting to IPR log_level ( str ): the logging level expression_variant_rows ( Iterable[Dict] ) structural_variant_rows ( Iterable[Dict] ) copy_variant_rows ( Iterable[Dict] ) small_mutation_rows ( Iterable[Dict] ) optional_content ( Optional[Dict] ): pass-through content to include in the JSON upload output_json_path ( str ): path to a JSON file to output the report upload body. always_write_output_json ( bool ): with successful IPR upload ipr_upload ( bool ): upload report to ipr interactive ( bool ): progressbars for interactive users cache_gene_minimum ( int ): minimum number of genes required for gene name caching optimization graphkb_url ( str ) Returns Optional[Dict] : ipr_conn.upload_report return dictionary","title":"ipr.main"},{"location":"reference/ipr/main/#iprmain","text":"","title":"ipr.main"},{"location":"reference/ipr/main/#cache_gene_minimum","text":"CACHE_GENE_MINIMUM = 5000","title":"CACHE_GENE_MINIMUM"},{"location":"reference/ipr/main/#clean_unsupported_content","text":"Remove unsupported content. This content is either added to facilitate creation or to support upcoming and soon to be supported content that we would like to implement but is not yet supported by the upload def clean_unsupported_content(upload_content: Dict) -> Dict: Args upload_content ( Dict ) Returns Dict","title":"clean_unsupported_content()"},{"location":"reference/ipr/main/#create_report","text":"Run the matching and create the report JSON for upload to IPR def create_report( username: str, password: str, patient_id: str, kb_disease_match: str, project: str = 'TEST', ipr_url: str = ipr.DEFAULT_URL, log_level: str = 'info', expression_variant_rows: Iterable[Dict] = [], structural_variant_rows: Iterable[Dict] = [], copy_variant_rows: Iterable[Dict] = [], small_mutation_rows: Iterable[Dict] = [], optional_content: Optional[Dict] = None, output_json_path: str = None, always_write_output_json: bool = False, ipr_upload: bool = True, interactive: bool = False, cache_gene_minimum: int = CACHE_GENE_MINIMUM, graphkb_url: str = '', ) -> Optional[Dict]: Args username ( str ): the username for connecting to GraphKB and IPR password ( str ): the password for connecting to GraphKB and IPR patient_id ( str ) kb_disease_match ( str ): disease name to be used in matching to GraphKB project ( str ) ipr_url ( str ): base URL to use in connecting to IPR log_level ( str ): the logging level expression_variant_rows ( Iterable[Dict] ) structural_variant_rows ( Iterable[Dict] ) copy_variant_rows ( Iterable[Dict] ) small_mutation_rows ( Iterable[Dict] ) optional_content ( Optional[Dict] ): pass-through content to include in the JSON upload output_json_path ( str ): path to a JSON file to output the report upload body. always_write_output_json ( bool ): with successful IPR upload ipr_upload ( bool ): upload report to ipr interactive ( bool ): progressbars for interactive users cache_gene_minimum ( int ): minimum number of genes required for gene name caching optimization graphkb_url ( str ) Returns Optional[Dict] : ipr_conn.upload_report return dictionary","title":"create_report()"},{"location":"reference/ipr/summary/","text":"ipr.summary OTHER_DISEASES OTHER_DISEASES = 'other disease types' ENTREZ_GENE_URL ENTREZ_GENE_URL = 'https://www.ncbi.nlm.nih.gov/gene' GRAPHKB_GUI GRAPHKB_GUI = 'https://graphkb.bcgsc.ca' filter_by_record_class() Given a list of records, return the subset matching a class or list of classes def filter_by_record_class( record_list: List[Dict], *record_classes, exclude: bool = False ) -> List[Dict]: Args record_list ( List[Dict] ) Returns List[Dict] generate_ontology_preference_key() Generate a tuple key for comparing preferred ontology terms. def generate_ontology_preference_key(record: Dict, sources_sort: Dict[str, int] = {}) -> Tuple: Args record ( Dict ) sources_sort ( Dict[str, int] ) Returns Tuple get_preferred_drug_representation() Given a Drug record, follow its linked records to find the preferred representation by following alias, deprecating, and cross reference links def get_preferred_drug_representation(graphkb_conn: GraphKBConnection, drug_record_id: str) -> Dict: Args graphkb_conn ( GraphKBConnection ) drug_record_id ( str ) Returns Dict create_graphkb_link() Create a link for a set of statements to the GraphKB client def create_graphkb_link(record_ids: List[str], record_class: str = 'Statement',) -> str: Args record_ids ( List[str] ) record_class ( str ) Returns str substitute_sentence_template() Create the filled-in sentence template for a given template and list of substitutions which may be the result of the aggregation of 1 or more statements def substitute_sentence_template( template: str, conditions: List[Record], subjects: List[Record], relevance: Record, evidence: List[Record], statement_rids: List[str] = [], disease_matches: Set[str] = set(), ) -> str: Args template ( str ) conditions ( List[Record] ) subjects ( List[Record] ) relevance ( Record ) evidence ( List[Record] ) statement_rids ( List[str] ) disease_matches ( Set[str] ) Returns str aggregate_statements() Group Statements that only differ in disease conditions and evidence def aggregate_statements( graphkb_conn: GraphKBConnection, template: str, statements: List[Statement], disease_matches: Set[str], ) -> Dict[str, str]: Args graphkb_conn ( GraphKBConnection ) template ( str ) statements ( List[Statement] ) disease_matches ( Set[str] ) Returns Dict[str, str] get_preferred_gene_name() Given some Feature record ID return the preferred gene name def get_preferred_gene_name(graphkb_conn: GraphKBConnection, record_id: str) -> str: Args graphkb_conn ( GraphKBConnection ) record_id ( str ) Returns str create_section_html() Generate HTML for a gene section of the comments def create_section_html( graphkb_conn: GraphKBConnection, gene_name: str, sentences_by_statement_id: Dict[str, str], statements: Dict[str, Statement], exp_variants: List[IprVariant], ) -> str: Args graphkb_conn ( GraphKBConnection ) gene_name ( str ) sentences_by_statement_id ( Dict[str, str] ) statements ( Dict[str, Statement] ) exp_variants (List[ IprVariant ]) Returns str section_statements_by_genes() Determine the statements associated with each gene name def section_statements_by_genes( graphkb_conn: GraphKBConnection, statements: Sequence[Statement] ) -> Dict[str, Set[str]]: Args graphkb_conn ( GraphKBConnection ) statements ( Sequence[Statement] ) Returns Dict[str, Set[str]] summarize() Given a list of GraphKB matches generate a text summary to add to the report def summarize( graphkb_conn: GraphKBConnection, matches: Sequence[KbMatch], disease_name: str, variants: List[IprVariant], ) -> str: Args graphkb_conn ( GraphKBConnection ) matches (Sequence[ KbMatch ]) disease_name ( str ) variants (List[ IprVariant ]) Returns str","title":"ipr.summary"},{"location":"reference/ipr/summary/#iprsummary","text":"","title":"ipr.summary"},{"location":"reference/ipr/summary/#other_diseases","text":"OTHER_DISEASES = 'other disease types'","title":"OTHER_DISEASES"},{"location":"reference/ipr/summary/#entrez_gene_url","text":"ENTREZ_GENE_URL = 'https://www.ncbi.nlm.nih.gov/gene'","title":"ENTREZ_GENE_URL"},{"location":"reference/ipr/summary/#graphkb_gui","text":"GRAPHKB_GUI = 'https://graphkb.bcgsc.ca'","title":"GRAPHKB_GUI"},{"location":"reference/ipr/summary/#filter_by_record_class","text":"Given a list of records, return the subset matching a class or list of classes def filter_by_record_class( record_list: List[Dict], *record_classes, exclude: bool = False ) -> List[Dict]: Args record_list ( List[Dict] ) Returns List[Dict]","title":"filter_by_record_class()"},{"location":"reference/ipr/summary/#generate_ontology_preference_key","text":"Generate a tuple key for comparing preferred ontology terms. def generate_ontology_preference_key(record: Dict, sources_sort: Dict[str, int] = {}) -> Tuple: Args record ( Dict ) sources_sort ( Dict[str, int] ) Returns Tuple","title":"generate_ontology_preference_key()"},{"location":"reference/ipr/summary/#get_preferred_drug_representation","text":"Given a Drug record, follow its linked records to find the preferred representation by following alias, deprecating, and cross reference links def get_preferred_drug_representation(graphkb_conn: GraphKBConnection, drug_record_id: str) -> Dict: Args graphkb_conn ( GraphKBConnection ) drug_record_id ( str ) Returns Dict","title":"get_preferred_drug_representation()"},{"location":"reference/ipr/summary/#create_graphkb_link","text":"Create a link for a set of statements to the GraphKB client def create_graphkb_link(record_ids: List[str], record_class: str = 'Statement',) -> str: Args record_ids ( List[str] ) record_class ( str ) Returns str","title":"create_graphkb_link()"},{"location":"reference/ipr/summary/#substitute_sentence_template","text":"Create the filled-in sentence template for a given template and list of substitutions which may be the result of the aggregation of 1 or more statements def substitute_sentence_template( template: str, conditions: List[Record], subjects: List[Record], relevance: Record, evidence: List[Record], statement_rids: List[str] = [], disease_matches: Set[str] = set(), ) -> str: Args template ( str ) conditions ( List[Record] ) subjects ( List[Record] ) relevance ( Record ) evidence ( List[Record] ) statement_rids ( List[str] ) disease_matches ( Set[str] ) Returns str","title":"substitute_sentence_template()"},{"location":"reference/ipr/summary/#aggregate_statements","text":"Group Statements that only differ in disease conditions and evidence def aggregate_statements( graphkb_conn: GraphKBConnection, template: str, statements: List[Statement], disease_matches: Set[str], ) -> Dict[str, str]: Args graphkb_conn ( GraphKBConnection ) template ( str ) statements ( List[Statement] ) disease_matches ( Set[str] ) Returns Dict[str, str]","title":"aggregate_statements()"},{"location":"reference/ipr/summary/#get_preferred_gene_name","text":"Given some Feature record ID return the preferred gene name def get_preferred_gene_name(graphkb_conn: GraphKBConnection, record_id: str) -> str: Args graphkb_conn ( GraphKBConnection ) record_id ( str ) Returns str","title":"get_preferred_gene_name()"},{"location":"reference/ipr/summary/#create_section_html","text":"Generate HTML for a gene section of the comments def create_section_html( graphkb_conn: GraphKBConnection, gene_name: str, sentences_by_statement_id: Dict[str, str], statements: Dict[str, Statement], exp_variants: List[IprVariant], ) -> str: Args graphkb_conn ( GraphKBConnection ) gene_name ( str ) sentences_by_statement_id ( Dict[str, str] ) statements ( Dict[str, Statement] ) exp_variants (List[ IprVariant ]) Returns str","title":"create_section_html()"},{"location":"reference/ipr/summary/#section_statements_by_genes","text":"Determine the statements associated with each gene name def section_statements_by_genes( graphkb_conn: GraphKBConnection, statements: Sequence[Statement] ) -> Dict[str, Set[str]]: Args graphkb_conn ( GraphKBConnection ) statements ( Sequence[Statement] ) Returns Dict[str, Set[str]]","title":"section_statements_by_genes()"},{"location":"reference/ipr/summary/#summarize","text":"Given a list of GraphKB matches generate a text summary to add to the report def summarize( graphkb_conn: GraphKBConnection, matches: Sequence[KbMatch], disease_name: str, variants: List[IprVariant], ) -> str: Args graphkb_conn ( GraphKBConnection ) matches (Sequence[ KbMatch ]) disease_name ( str ) variants (List[ IprVariant ]) Returns str","title":"summarize()"},{"location":"reference/ipr/types/","text":"ipr.types IprVariant IprVariant = Union[IprGeneVariant, IprStructuralVariant] class KbMatch inherits TypedDict Attributes variant ( str ) variantType ( str ) approvedTherapy ( bool ) category ( str ) context ( str ) disease ( str ) evidenceLevel ( str ) kbStatementId ( str ) kbVariant ( str ) kbVariantId ( str ) matchedCancer ( bool ) reference ( str ) relevance ( str ) class IprGeneVariant inherits TypedDict Attributes gene ( str ) key ( str ) variantType ( str ) variant ( str ) class IprGene inherits TypedDict Attributes name ( str ) cancerRelated ( Optional[bool] ) knownFusionPartner ( Optional[bool] ) knownSmallMutation ( Optional[bool] ) tumourSuppressor ( Optional[bool] ) oncogene ( Optional[bool] ) therapeuticAssociated ( Optional[bool] ) class IprStructuralVariant inherits TypedDict Attributes key ( str ) variantType ( str ) variant ( str ) gene1 ( str ) gene2 ( str ) exon1 ( int ) exon2 ( int ) class ImageDefinition inherits TypedDict Attributes key ( str ) path ( str )","title":"ipr.types"},{"location":"reference/ipr/types/#iprtypes","text":"","title":"ipr.types"},{"location":"reference/ipr/types/#iprvariant","text":"IprVariant = Union[IprGeneVariant, IprStructuralVariant]","title":"IprVariant"},{"location":"reference/ipr/types/#class-kbmatch","text":"inherits TypedDict Attributes variant ( str ) variantType ( str ) approvedTherapy ( bool ) category ( str ) context ( str ) disease ( str ) evidenceLevel ( str ) kbStatementId ( str ) kbVariant ( str ) kbVariantId ( str ) matchedCancer ( bool ) reference ( str ) relevance ( str )","title":"class KbMatch"},{"location":"reference/ipr/types/#class-iprgenevariant","text":"inherits TypedDict Attributes gene ( str ) key ( str ) variantType ( str ) variant ( str )","title":"class IprGeneVariant"},{"location":"reference/ipr/types/#class-iprgene","text":"inherits TypedDict Attributes name ( str ) cancerRelated ( Optional[bool] ) knownFusionPartner ( Optional[bool] ) knownSmallMutation ( Optional[bool] ) tumourSuppressor ( Optional[bool] ) oncogene ( Optional[bool] ) therapeuticAssociated ( Optional[bool] )","title":"class IprGene"},{"location":"reference/ipr/types/#class-iprstructuralvariant","text":"inherits TypedDict Attributes key ( str ) variantType ( str ) variant ( str ) gene1 ( str ) gene2 ( str ) exon1 ( int ) exon2 ( int )","title":"class IprStructuralVariant"},{"location":"reference/ipr/types/#class-imagedefinition","text":"inherits TypedDict Attributes key ( str ) path ( str )","title":"class ImageDefinition"},{"location":"reference/ipr/util/","text":"ipr.util VERBOSE_ERROR_CODE VERBOSE_ERROR_CODE = (logging.INFO + logging.DEBUG) // 2 logger logger = logging.getLogger('genomic_report') LOG_LEVELS LOG_LEVELS = { 'info': logging.INFO, 'debug': logging.DEBUG, 'warn': logging.WARN, 'error': logging.ERROR, 'verbose': VERBOSE_ERROR_CODE,","title":"ipr.util"},{"location":"reference/ipr/util/#iprutil","text":"","title":"ipr.util"},{"location":"reference/ipr/util/#verbose_error_code","text":"VERBOSE_ERROR_CODE = (logging.INFO + logging.DEBUG) // 2","title":"VERBOSE_ERROR_CODE"},{"location":"reference/ipr/util/#logger","text":"logger = logging.getLogger('genomic_report')","title":"logger"},{"location":"reference/ipr/util/#log_levels","text":"LOG_LEVELS = { 'info': logging.INFO, 'debug': logging.DEBUG, 'warn': logging.WARN, 'error': logging.ERROR, 'verbose': VERBOSE_ERROR_CODE,","title":"LOG_LEVELS"}]}